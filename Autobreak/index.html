<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Orb Weaver 2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        /* Make the canvas a circle with a glowing border */
        #gameCanvas {
            border-radius: 50%;
            border: 4px solid;
            box-shadow: 0 0 20px rgba(129, 140, 248, 0.5);
            transition: box-shadow 0.5s ease-in-out;
            cursor: pointer;
        }
        .control-label {
            @apply text-sm font-medium text-gray-300;
        }
        .control-value {
             @apply text-sm font-bold text-white;
        }
        .slider {
            @apply w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer;
        }
        .slider::-webkit-slider-thumb {
            @apply w-5 h-5 bg-indigo-500 rounded-full appearance-none;
        }
        .slider::-moz-range-thumb {
            @apply w-5 h-5 bg-indigo-500 rounded-full border-none;
        }
        /* Style for game screens */
        .game-screen {
            @apply absolute inset-0 flex flex-col items-center justify-center p-4 transition-opacity duration-500 ease-in-out;
            background: rgba(12, 10, 29, 0.9);
            z-index: 10;
        }
        .orb-icon {
            @apply text-2xl;
        }
        .orb-special {
            @apply text-yellow-300;
            text-shadow: 0 0 10px rgba(253, 224, 71, 0.8);
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto relative">
        <h1 class="text-3xl font-bold text-center mb-4 text-purple-400">Magical Orb Weaver</h1>

        <!-- Game Info: Score, Lives, Level, Time -->
        <div class="grid grid-cols-4 gap-2 md:gap-4 mb-4 text-center bg-gray-800 bg-opacity-50 p-4 rounded-xl shadow-lg">
            <div>
                <p class="text-xs md:text-sm font-medium text-gray-400">Score</p>
                <p id="score" class="text-xl md:text-2xl font-bold text-green-400">0</p>
            </div>
            <div>
                <p class="text-xs md:text-sm font-medium text-gray-400">Lives</p>
                <p id="lives" class="text-xl md:text-2xl font-bold text-red-400">3</p>
            </div>
            <div>
                <p class="text-xs md:text-sm font-medium text-gray-400">Level</p>
                <p id="level" class="text-xl md:text-2xl font-bold text-purple-400">1</p>
            </div>
            <div>
                <p class="text-xs md:text-sm font-medium text-gray-400">Time</p>
                <p id="timer" class="text-xl md:text-2xl font-bold text-cyan-400">00:00</p>
            </div>
        </div>

        <!-- Start Game Screen -->
        <div id="startScreen" class="game-screen">
            <h2 class="text-4xl font-extrabold text-white mb-4 animate-pulse">Magical Orb Weaver</h2>
            <p class="text-lg text-gray-300 mb-8 max-w-sm text-center">
                Click or tap the screen to launch the orb. Collect all the orbs to advance!
            </p>
            <button id="startButton" class="px-8 py-4 text-lg font-bold text-white bg-purple-600 rounded-full shadow-lg hover:bg-purple-700 transition duration-300">
                Start Game
            </button>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="game-screen hidden">
            <h2 class="text-4xl font-extrabold text-red-400 mb-4">Game Over</h2>
            <p id="finalScore" class="text-lg text-white mb-2">Final Score: 0</p>
            <p id="levelsCompleted" class="text-lg text-white mb-8">Levels Completed: 0</p>
            <button id="restartButton" class="px-8 py-4 text-lg font-bold text-white bg-green-600 rounded-full shadow-lg hover:bg-green-700 transition duration-300">
                Play Again
            </button>
        </div>

        <!-- Canvas for the game -->
        <canvas id="gameCanvas"></canvas>

        <!-- Game Controls -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4 bg-gray-800 bg-opacity-50 p-6 rounded-xl shadow-lg">
            <!-- Orb Speed Slider -->
            <div class="w-full">
                <label for="speed" class="control-label">Orb Speed: <span id="speedValue" class="control-value">4</span></label>
                <input type="range" id="speed" min="1" max="15" value="4" class="slider">
            </div>
            
            <!-- Bounce Offset Slider -->
            <div class="w-full">
                <label for="bounceOffset" class="control-label">Bounce Offset: <span id="bounceOffsetValue" class="control-value">0°</span></label>
                <input type="range" id="bounceOffset" min="-45" max="45" value="0" class="slider">
            </div>
        </div>
        
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // UI Elements
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const levelEl = document.getElementById('level');
        const timerEl = document.getElementById('timer');
        const speedSlider = document.getElementById('speed');
        const speedValueEl = document.getElementById('speedValue');
        const bounceOffsetSlider = document.getElementById('bounceOffset');
        const bounceOffsetValueEl = document.getElementById('bounceOffsetValue');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const finalScoreEl = document.getElementById('finalScore');
        const levelsCompletedEl = document.getElementById('levelsCompleted');

        let animationFrameId;
        let startTime, timerInterval;

        // Game state variables
        let center, radius, ball, entities, particles, stars;
        let score, lives, currentLevel, bounceOffsetDegrees = 0;
        let gameState = 'start'; // 'start', 'playing', 'gameOver'
        let hasLaunched = false;
        let scoreMultiplier = 1;
        let multiplierTimer = null;

        // --- Audio Setup (using Tone.js) ---
        const hitSynth = new Tone.Synth({
            oscillator: { type: "sine" },
            envelope: {
                attack: 0.001,
                decay: 0.1,
                sustain: 0,
                release: 0.1
            }
        }).toDestination();
        
        const specialHitSynth = new Tone.Synth({
            oscillator: { type: "triangle" },
            envelope: {
                attack: 0.005,
                decay: 0.2,
                sustain: 0,
                release: 0.5
            }
        }).toDestination();

        const missSynth = new Tone.Synth({
            oscillator: { type: "sawtooth" },
            envelope: {
                attack: 0.01,
                decay: 0.5,
                sustain: 0,
                release: 1
            }
        }).toDestination();
        
        function playHitSound() { hitSynth.triggerAttackRelease("C4", "8n"); }
        function playSpecialHitSound() { specialHitSynth.triggerAttackRelease("G5", "4n"); }
        function playMissSound() { missSynth.triggerAttackRelease("F#2", "4n"); }

        // --- Game Setup ---
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth, window.innerHeight * 0.6);
            canvas.width = size;
            canvas.height = size;
            center = { x: canvas.width / 2, y: canvas.height / 2 };
            radius = Math.min(canvas.width, canvas.height) / 2 - 10;
            createStars();
            if (ball) {
                ball.radius = Math.max(6, radius * 0.03);
            }
        }

        function init() {
            // Reset game state
            score = 0;
            lives = 3;
            currentLevel = 1;
            particles = [];
            hasLaunched = false;
            scoreMultiplier = 1;
            
            ball = createBall();
            
            loadLevel(currentLevel);
            
            startTime = Date.now();
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
            
            updateUI();
            
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        }

        function loadLevel(level) {
            entities = [];
            ball.color = `hsl(${(level * 25) % 360}, 100%, 65%)`;
            
            const orbCount = 10 + level * 2;
            const entityType = Math.floor((level -1) / 5) % 4;
            let specialOrbAdded = false;

            for (let i = 0; i < orbCount; i++) {
                 // Add a special orb on specific levels
                 if (i === Math.floor(orbCount / 2) && !specialOrbAdded) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * (radius * 0.8) + (radius * 0.1);
                    const x = center.x + Math.cos(angle) * dist;
                    const y = center.y + Math.sin(angle) * dist;
                    entities.push({
                        x, y,
                        type: 'special',
                        size: Math.max(8, (radius / 20)),
                        color: `hsl(${Math.random() * 360}, 80%, 70%)`,
                        visible: true,
                        rotation: 0,
                        pulse: Math.random()
                    });
                    specialOrbAdded = true;
                    continue;
                 }

                // Ensure entities are placed randomly within the circular play area
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * (radius * 0.8) + (radius * 0.1);
                const x = center.x + Math.cos(angle) * dist;
                const y = center.y + Math.sin(angle) * dist;
                
                entities.push({
                    x, y,
                    type: 'normal',
                    size: Math.max(3, (radius / 30) - (Math.random()*2)),
                    color: `hsl(${Math.random() * 360}, 80%, 70%)`,
                    visible: true,
                    rotation: 0,
                    pulse: Math.random()
                });
            }
            updateUI();
        }

        // --- Background and Effects ---
        function createStars() {
            stars = [];
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 1.5 + 0.5,
                    opacity: Math.random() * 0.5 + 0.2,
                    speed: Math.random() * 0.1 + 0.05
                });
            }
        }
        
        function drawBackground() {
            ctx.fillStyle = 'rgba(12, 10, 29, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const gradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, radius * 1.5);
            gradient.addColorStop(0, '#1E1B4B');
            gradient.addColorStop(1, '#0C0A1D');
            
            ctx.save();
            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.restore();

            ctx.save();
            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
            ctx.clip();
            
            stars.forEach(star => {
                star.x += star.speed;
                if (star.x > canvas.width) star.x = 0;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                ctx.fill();
            });
            ctx.restore();
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x, y,
                    dx: (Math.random() - 0.5) * 3,
                    dy: (Math.random() - 0.5) * 3,
                    size: Math.random() * 2 + 1,
                    life: 1,
                    color: color
                });
            }
        }

        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.dx;
                p.y += p.dy;
                p.life -= 0.03;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.globalAlpha = p.life;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            }
        }

        // --- Drawing Functions ---
        function drawBall() {
            ctx.shadowColor = ball.color;
            // Pulsing shadow for power-up state
            ctx.shadowBlur = scoreMultiplier > 1 ? 30 + Math.sin(Date.now() / 100) * 10 : 20;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = ball.color;
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawEntities() {
            entities.forEach(e => {
                if (e.visible) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    e.pulse = (e.pulse + 0.02) % (Math.PI * 2);
                    const scale = 1 + Math.sin(e.pulse) * 0.1;

                    if (e.type === 'special') {
                        // Draw star icon for special orb
                        ctx.font = `${e.size * 2}px sans-serif`;
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText('⭐', 0, 0);
                    } else {
                        // Draw normal orb shapes
                        ctx.rotate(e.rotation);
                        e.rotation += 0.005;
                        ctx.shadowColor = e.color;
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = e.color;
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 1;

                        switch(Math.floor(Math.random()*4)) { // Randomize shape on each level
                            case 0: // Pulsating Orbs
                                ctx.beginPath();
                                ctx.arc(0, 0, e.size * scale, 0, Math.PI * 2);
                                ctx.fill();
                                break;
                            case 1: // Rotating Squares
                                ctx.fillRect(-e.size * scale / 2, -e.size * scale / 2, e.size * scale, e.size * scale);
                                break;
                            case 2: // Rotating Triangles
                                ctx.beginPath();
                                ctx.moveTo(0, -e.size * scale);
                                ctx.lineTo(e.size * scale, e.size * scale);
                                ctx.lineTo(-e.size * scale, e.size * scale);
                                ctx.closePath();
                                ctx.fill();
                                break;
                            case 3: // Crystalline Shards
                                ctx.beginPath();
                                for(let i = 0; i < 5; i++) {
                                    let angle = (i / 5) * Math.PI * 2;
                                    let size = i % 2 === 0 ? e.size * scale : e.size * scale * 0.5;
                                    ctx.lineTo(Math.cos(angle) * size, Math.sin(angle) * size);
                                }
                                ctx.closePath();
                                ctx.stroke();
                                break;
                        }
                    }
                    ctx.restore();
                }
            });
            ctx.shadowBlur = 0;
        }
        
        // --- Game Logic ---
        function updateBallPosition() {
            if (hasLaunched) {
                ball.x += ball.dx;
                ball.y += ball.dy;
            }
        }
        
        function handleBallBoundary() {
            const distFromCenter = Math.sqrt((ball.x - center.x) ** 2 + (ball.y - center.y) ** 2);

            // Check for game over (if ball goes too far outside)
            if (distFromCenter > radius + ball.radius + 5) {
                playMissSound();
                lives--;
                updateUI();
                if (lives > 0) {
                    resetBall();
                } else {
                    endGame();
                }
                return;
            }

            // Outer wall bounce collision
            if (distFromCenter + ball.radius > radius) {
                const normalX = (ball.x - center.x) / distFromCenter;
                const normalY = (ball.y - center.y) / distFromCenter;

                const dotProduct = ball.dx * normalX + ball.dy * normalY;

                let reflectedDx = ball.dx - 2 * dotProduct * normalX;
                let reflectedDy = ball.dy - 2 * dotProduct * normalY;

                const angleInRadians = bounceOffsetDegrees * Math.PI / 180;
                const cos = Math.cos(angleInRadians);
                const sin = Math.sin(angleInRadians);
                
                ball.dx = reflectedDx * cos - reflectedDy * sin;
                ball.dy = reflectedDx * sin + reflectedDy * cos;

                ball.x = center.x + normalX * (radius - ball.radius);
                ball.y = center.y + normalY * (radius - ball.radius);
            }
        }

        function handleEntityCollisions() {
            let orbsRemaining = false;
            for (let i = entities.length - 1; i >= 0; i--) {
                const e = entities[i];
                if (e.visible) {
                    const dx = e.x - ball.x;
                    const dy = e.y - ball.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < e.size + ball.radius) {
                        e.visible = false;
                        if (e.type === 'special') {
                            playSpecialHitSound();
                            score += 100 * scoreMultiplier;
                            scoreMultiplier = 5;
                            // Reset multiplier after 5 seconds
                            if (multiplierTimer) clearTimeout(multiplierTimer);
                            multiplierTimer = setTimeout(() => {
                                scoreMultiplier = 1;
                            }, 5000);
                        } else {
                            playHitSound();
                            score += 10 * scoreMultiplier;
                        }
                        createParticles(ball.x, ball.y, e.color);
                        updateUI();
                        
                        // Simple reflection on entity collision
                        ball.dx *= -1;
                        ball.dy *= -1;
                    } else {
                        orbsRemaining = true;
                    }
                }
            }
            if (!orbsRemaining) {
                 winLevel();
            }
        }
        
        function createBall() {
            const speed = parseInt(speedSlider.value, 10);
            return {
                x: center.x,
                y: center.y,
                radius: Math.max(6, radius * 0.03),
                speed: speed,
                dx: 0,
                dy: 0,
                color: '#FFFFFF'
            };
        }

        function resetBall() {
            hasLaunched = false;
            ball.x = center.x;
            ball.y = center.y;
            ball.dx = 0;
            ball.dy = 0;
            updateUI();
        }

        function winLevel() {
            currentLevel++;
            scoreMultiplier = 1;
            loadLevel(currentLevel);
            resetBall();
        }

        function endGame() {
            gameState = 'gameOver';
            cancelAnimationFrame(animationFrameId);
            clearInterval(timerInterval);
            finalScoreEl.textContent = `Final Score: ${score}`;
            levelsCompletedEl.textContent = `Levels Completed: ${currentLevel - 1}`;
            gameOverScreen.classList.remove('hidden');
        }

        function updateUI() {
            scoreEl.textContent = score;
            livesEl.textContent = lives;
            levelEl.textContent = currentLevel;
        }

        function updateTimer() {
            if (gameState === 'playing') {
                const now = Date.now();
                const elapsed = Math.floor((now - startTime) / 1000);
                const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
                const seconds = String(elapsed % 60).padStart(2, '0');
                timerEl.textContent = `${minutes}:${seconds}`;
            }
        }

        // --- Game Loop ---
        function gameLoop() {
            if (gameState === 'playing') {
                drawBackground();
                ctx.save();
                ctx.beginPath();
                ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
                ctx.clip();
                drawBall();
                drawEntities();
                drawParticles();
                ctx.restore();
                updateBallPosition();
                handleBallBoundary();
                handleEntityCollisions();
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        speedSlider.addEventListener('input', (e) => {
            const newSpeed = parseInt(e.target.value, 10);
            speedValueEl.textContent = newSpeed;
            if (ball && hasLaunched) {
                const currentSpeed = Math.sqrt(ball.dx ** 2 + ball.dy ** 2);
                if (currentSpeed > 0) {
                    const ratio = newSpeed / currentSpeed;
                    ball.dx *= ratio;
                    ball.dy *= ratio;
                }
                ball.speed = newSpeed;
            }
        });

        bounceOffsetSlider.addEventListener('input', (e) => {
            bounceOffsetDegrees = parseInt(e.target.value, 10);
            bounceOffsetValueEl.textContent = `${bounceOffsetDegrees}°`;
        });

        startButton.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            gameState = 'playing';
            init();
        });

        restartButton.addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            gameState = 'playing';
            init();
        });
        
        canvas.addEventListener('mousedown', launchBall);
        canvas.addEventListener('touchstart', launchBall);

        function launchBall(event) {
            if (!hasLaunched && gameState === 'playing') {
                let rect = canvas.getBoundingClientRect();
                let clickX = (event.clientX || event.touches[0].clientX) - rect.left;
                let clickY = (event.clientY || event.touches[0].clientY) - rect.top;

                let dx = clickX - ball.x;
                let dy = clickY - ball.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                
                // Set ball velocity
                ball.dx = (dx / dist) * ball.speed;
                ball.dy = (dy / dist) * ball.speed;

                hasLaunched = true;
            }
        }

        window.addEventListener('resize', resizeCanvas);

        // Initial setup
        window.onload = () => {
            resizeCanvas();
            gameLoop();
        };
    </script>
</body>
</html>

