<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Magical Orb Weaver ‚Äî Shapes, Bosses & Powerups</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root { color-scheme: dark; }
    body { font-family: 'Inter', sans-serif; overflow: hidden; touch-action: none; }
    canvas { display:block; width:100%; height:100%; cursor:none; }

    /* ---- Portal frame (masked viewport) ---- */
    .portal {
      position: relative;
      overflow: hidden;
      isolation: isolate;
      aspect-ratio: 1/1;
      box-shadow:
        0 0 0 2px rgba(99,102,241,0.25) inset,
        0 10px 40px rgba(0,0,0,0.45);
      background: transparent;
    }

    /* Mask shapes */
    .shape-circle { border-radius: 9999px; clip-path: circle(50% at 50% 50%); }
    .shape-ellipse { border-radius: 50%/40%; clip-path: ellipse(50% 40% at 50% 50%); }
    .shape-hexagon { clip-path: polygon(25% 5%, 75% 5%, 100% 50%, 75% 95%, 25% 95%, 0% 50%); }
    .shape-square  { border-radius: 1rem; clip-path: inset(0 round 1rem); }

    /* Neon halo (two spinning layers) */
    .portal::before, .portal::after {
      content:""; position:absolute; inset:-3%; z-index:-1; border-radius:50%;
      filter: blur(22px); animation: spin 18s linear infinite;
      background: conic-gradient(from 0deg,
                  rgba(168,85,247,0.0) 0deg,
                  rgba(99,102,241,0.9) 60deg,
                  rgba(34,211,238,0.9) 140deg,
                  rgba(20,184,166,0.9) 220deg,
                  rgba(168,85,247,0.9) 300deg,
                  rgba(168,85,247,0.0) 360deg);
      opacity:.55; pointer-events:none;
    }
    .portal::after { inset:-6%; filter: blur(40px); animation-duration:28s; animation-direction:reverse; opacity:.35; }

    /* Breathing inner aura */
    .breath { position:absolute; inset:-8%; pointer-events:none; border-radius:50%;
      background: radial-gradient(closest-side,
                  rgba(168,85,247,0.25),
                  rgba(99,102,241,0.15) 45%,
                  rgba(34,211,238,0.08) 70%,
                  rgba(0,0,0,0) 100%);
      filter: blur(10px); animation: breathe 3.8s ease-in-out infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    @keyframes breathe { 0%,100% { opacity:.55; transform:scale(1.00); } 50% { opacity:.85; transform:scale(1.03); } }

    .chip { font-size:.70rem; padding:.35rem .55rem; border-radius:.5rem; background: rgba(31,41,55,.6); color:#d1d5db; }
    .badge { font-size:.70rem; padding:.20rem .45rem; border-radius:.375rem; background: rgba(31,41,55,.85); color:#e5e7eb; border:1px solid rgba(148,163,184,.25); }

    /* Boss HP bar */
    .hp-wrap { height: 10px; background: rgba(2,6,23,.6); border-radius: 9999px; overflow: hidden; border: 1px solid rgba(148,163,184,.25); }
    .hp-bar  { height: 100%; background: linear-gradient(90deg, #f43f5e, #fb7185); }
  </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">
  <div class="w-full max-w-4xl mx-auto">
    <h1 class="text-3xl font-bold text-center mb-4">
      <span class="bg-clip-text text-transparent bg-gradient-to-r from-fuchsia-400 via-indigo-400 to-cyan-300">
        Magical Orb Weaver
      </span>
    </h1>

    <!-- HUD -->
    <div class="grid grid-cols-3 gap-4 mb-2 text-center bg-gray-800/60 p-4 rounded-xl shadow-lg">
      <div><p class="text-sm font-medium text-gray-400">Score</p><p id="score" class="text-2xl font-bold text-emerald-400">0</p></div>
      <div><p class="text-sm font-medium text-gray-400">Level</p><p id="level" class="text-2xl font-bold text-purple-400">1</p></div>
      <div><p class="text-sm font-medium text-gray-400">Time</p><p id="timer" class="text-2xl font-bold text-cyan-400">00:00</p></div>
    </div>

    <!-- Boss bar -->
    <div id="bossPanel" class="mb-3 hidden">
      <div class="flex items-center justify-between text-xs text-pink-200 mb-1">
        <span>Guardian Integrity</span><span id="bossHpLabel"></span>
      </div>
      <div class="hp-wrap"><div id="bossHpBar" class="hp-bar" style="width: 100%;"></div></div>
    </div>

    <!-- Active effects -->
    <div class="mb-4 bg-gray-800/60 p-3 rounded-xl shadow-lg">
      <div class="flex flex-wrap gap-2 items-center">
        <span class="text-xs text-gray-400">Active:</span>
        <div id="effectsBar" class="flex flex-wrap gap-2"></div>
      </div>
    </div>

    <!-- Portal viewport -->
    <div id="portalWrap" class="portal shape-circle mx-auto w-full" style="max-width: min(90vw, 640px);">
      <div class="breath"></div>
      <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Controls -->
    <div class="grid grid-cols-1 mt-5 bg-gray-800/60 p-6 rounded-xl shadow-lg gap-6">
      <div class="grid md:grid-cols-2 gap-6">
        <div>
          <label for="speed" class="text-sm font-medium text-gray-300">Game Speed:
            <span id="speedValue" class="text-sm font-bold text-white">8</span>
          </label>
          <input id="speed" type="range" min="1" max="20" value="8" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
        </div>

        <div>
          <label for="offset" class="text-sm font-medium text-gray-300">Boundary Offset (¬∞):
            <span id="offsetValue" class="text-sm font-bold text-white">0</span>
          </label>
          <input id="offset" type="range" min="-45" max="45" value="0" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
        </div>
      </div>

      <div class="grid md:grid-cols-3 gap-6 items-start">
        <div>
          <label class="text-sm font-medium text-gray-300">Viewport Shape:
            <span id="shapeLabel" class="text-sm font-bold text-white">Circle</span>
          </label>
          <select id="shapeSelect" class="mt-2 w-full bg-gray-700/70 border border-gray-600 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-400">
            <option value="circle" selected>Circle</option>
            <option value="ellipse">Ellipse</option>
            <option value="hexagon">Hexagon</option>
            <option value="square">Square</option>
          </select>
        </div>

        <div id="ellipsePanel" class="hidden">
          <label for="ellipseRatio" class="text-sm font-medium text-gray-300">Ellipse Vertical Ratio:
            <span id="ellipseRatioValue" class="text-sm font-bold text-white">0.80</span>
          </label>
          <input id="ellipseRatio" type="range" min="0.50" max="1.00" step="0.01" value="0.80" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
          <p class="text-xs text-gray-400 mt-1">Ry = ratio √ó R, Rx = R</p>
        </div>

        <div>
          <label class="text-sm font-medium text-gray-300">Polygon Rotation (¬∞):
            <span id="polyRotLabel" class="text-sm font-bold text-white">0</span>
          </label>
          <input id="polyRot" type="range" min="0" max="359" value="0" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
          <p class="text-xs text-gray-400 mt-1">Affects hexagon & square</p>
        </div>
      </div>

      <div class="grid md:grid-cols-3 gap-6">
        <div class="space-y-1">
          <label class="text-sm font-medium text-gray-300 flex items-center gap-2">
            <input id="randToggle" type="checkbox" class="accent-indigo-400"> Random Bounce Offset
          </label>
          <label class="text-xs text-gray-400">¬±<span id="randAmtLabel">10</span>¬∞</label>
          <input id="randAmt" type="range" min="0" max="45" value="10" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
          <label class="text-xs text-gray-400 flex items-center gap-2 mt-1">
            <input id="randOnEntity" type="checkbox" class="accent-indigo-400"> Apply to entity/boss hits too
          </label>
        </div>

        <div class="flex items-end justify-center gap-2">
          <span class="chip">Space = Pause/Resume</span>
          <span class="chip">R = Reset</span>
          <span class="chip">Boss every 10 levels</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ------- DOM refs -------
    const portalWrap = document.getElementById('portalWrap');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const timerEl = document.getElementById('timer');
    const effectsBar = document.getElementById('effectsBar');

    const speedSlider = document.getElementById('speed');     const speedValueEl = document.getElementById('speedValue');
    const offsetSlider = document.getElementById('offset');   const offsetValueEl = document.getElementById('offsetValue');

    const shapeSelect = document.getElementById('shapeSelect'); const shapeLabel = document.getElementById('shapeLabel');
    const ellipsePanel = document.getElementById('ellipsePanel');
    const ellipseRatioSlider = document.getElementById('ellipseRatio'); const ellipseRatioValue = document.getElementById('ellipseRatioValue');

    const polyRot = document.getElementById('polyRot'); const polyRotLabel = document.getElementById('polyRotLabel');

    const randToggle = document.getElementById('randToggle');
    const randAmt = document.getElementById('randAmt'); const randAmtLabel = document.getElementById('randAmtLabel');
    const randOnEntity = document.getElementById('randOnEntity');

    const bossPanel = document.getElementById('bossPanel');
    const bossHpBar = document.getElementById('bossHpBar');
    const bossHpLabel = document.getElementById('bossHpLabel');

    // ------- Runtime/state -------
    let shape = 'circle';              // 'circle' | 'ellipse' | 'hexagon' | 'square'
    let ellipseRatio = 0.80;           // Ry / R for ellipse
    let polyRotation = 0;              // radians
    let center, logicalSize, radius;   // boundary size
    let dpr = Math.max(1, window.devicePixelRatio || 1);

    let animationFrameId, lastTs = 0, paused = false;
    let startTime, timerInterval, levelInterval;

    // scanning highlighter
    let scanT = 0; // 0..1 along boundary

    // game entities
    let balls = [];                    // multiple balls for MULTI effect
    let entities = [], particles = [], stars = [];
    let powerups = [];                 // on-field
    let activeEffects = [];            // {type, until}
    let score = 0, currentLevel = 1;

    // boss
    let boss = null;                   // {x,y,r, hp, hpMax, angle, speed}

    // powerup timing
    let spawnTimer = 0;                // ms to next spawn

    // ------- Helpers -------
    const TAU = Math.PI * 2;
    const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
    const lerp  = (a,b,t) => a + (b-a)*t;

    function rotateVec(dx, dy, rad){ const c=Math.cos(rad), s=Math.sin(rad); return {dx: dx*c - dy*s, dy: dx*s + dy*c}; }
    function setMagnitude(dx, dy, mag){ const len = Math.hypot(dx,dy) || 1; return {dx: dx/len*mag, dy: dy/len*mag}; }

    function currentSpeedBase(){ return parseInt(speedSlider.value, 10); }
    function boundaryOffsetRad(){ return (parseInt(offsetSlider.value, 10) || 0) * (Math.PI/180); }
    function randomOffsetRad(){ return (randToggle.checked ? ((Math.random()*2 - 1) * parseInt(randAmt.value,10))*(Math.PI/180) : 0); }
    function maybeRandomizeAngle(rad){ return rad + randomOffsetRad(); }
    function maybeRandomizeAngleOnEntity(rad){ return (randToggle.checked && randOnEntity.checked) ? rad + randomOffsetRad() : rad; }

    function effectSpeedMultiplier(){
      let m = 1.0;
      for(const e of activeEffects){ if(e.type==='SPEED_UP') m *= 1.8; if(e.type==='SLOW') m *= 0.6; }
      return m;
    }
    function effectScoreMultiplier(){
      let m = 1.0;
      for(const e of activeEffects){ if(e.type==='SCORE_X2') m *= 2.0; }
      return m;
    }
    function effectiveSpeed(){ return currentSpeedBase() * effectSpeedMultiplier(); }

    function hasShield(){ return activeEffects.some(e => e.type==='SHIELD'); }
    function consumeShield(){
      const idx = activeEffects.findIndex(e => e.type==='SHIELD');
      if (idx !== -1) activeEffects.splice(idx,1);
    }

    // ------- Canvas/viewport -------
    function fitCanvas(){
      const cssSize = portalWrap.clientWidth;
      logicalSize = Math.floor(cssSize);

      canvas.style.width = logicalSize + 'px';
      canvas.style.height = logicalSize + 'px';

      dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width  = Math.floor(logicalSize * dpr);
      canvas.height = Math.floor(logicalSize * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      center = { x: logicalSize/2, y: logicalSize/2 };
      radius = (logicalSize/2) - 18; // leave room for ring

      createStars();
      for (const b of balls){
        b.x = center.x; b.y = center.y;
        b.radius = Math.max(6, radius * 0.03);
      }
      if (balls.length === 0) {
        spawnBall();
      }
    }

    // ------- Init/reset -------
    function init(){
      score = 0; currentLevel = 1; particles = []; powerups = []; activeEffects = []; boss = null;
      balls = []; spawnBall();

      loadLevel(currentLevel);

      startTime = Date.now();
      clearInterval(timerInterval); clearInterval(levelInterval);
      timerInterval = setInterval(updateTimer, 1000);
      levelInterval = setInterval(levelUp, 20000);

      paused = false; lastTs = performance.now();
      cancelAnimationFrame(animationFrameId);
      animationFrameId = requestAnimationFrame(gameLoop);

      spawnTimer = 4000; // first powerup ~4s
      updateUI(); updateEffectsUI(); updateBossUI();
    }

    // ------- Ball helpers -------
    function spawnBall(dirAngle){
      const sp = effectiveSpeed();
      const angle = (dirAngle !== undefined) ? dirAngle : Math.random()*TAU;
      balls.push({
        x:center.x, y:center.y,
        radius: Math.max(6, radius*0.03),
        dx: Math.cos(angle)*sp, dy: Math.sin(angle)*sp,
        color: '#FFFFFF'
      });
    }

    function ensureMultiBallActive(){
      // MULTI effect -> keep 3 balls
      const isMulti = activeEffects.some(e=>e.type==='MULTI');
      if (isMulti && balls.length < 3){
        // add balls spread by small angle
        const baseAngle = Math.atan2(balls[0].dy, balls[0].dx);
        spawnBall(baseAngle + 0.3);
        spawnBall(baseAngle - 0.3);
      }
      if (!isMulti && balls.length > 1){
        // revert to single ball (keep the first)
        balls = [balls[0]];
      }
    }

    // ------- Level/Entities -------
    function loadLevel(level){
      entities = [];
      balls.forEach((b,i)=> b.color = `hsl(${(level * 25 + i*20) % 360}, 100%, 65%)`);

      const isBoss = (level % 10 === 0);
      if (isBoss){
        const hpBase = 20 + Math.floor(level*1.5);
        boss = {
          x:center.x + radius*0.5, y:center.y, r: Math.max(28, radius*0.08),
          hp: hpBase, hpMax: hpBase,
          angle: Math.random()*TAU, speed: 0.4 + (level/60)
        };
      } else {
        boss = null;
        const rows = Math.min(15, 3 + Math.floor(level/5));
        const cols = 12 + Math.floor(level/4);
        const entityType = Math.floor((level-1)/10) % 4;

        for (let r=0; r<rows; r++){
          for (let c=0; c<cols; c++){
            if (Math.random() > 0.4){
              const ang = (c/cols) * TAU;
              const dist = radius * 0.18 + (r/rows) * radius * 0.62;
              const x = center.x + Math.cos(ang) * dist;
              const y = center.y + Math.sin(ang) * dist;
              entities.push({
                x,y, type: entityType,
                size: Math.max(3, (radius/30) - (r/2)),
                color: `hsl(${(r*20 + c*5) % 360}, 80%, 70%)`,
                visible: true, rotation:0, pulse: Math.random()
              });
            }
          }
        }
      }
      updateUI(); updateBossUI();
    }

    function levelUp(){
      currentLevel++;
      loadLevel(currentLevel);
    }

    // ------- Background & Effects -------
    function createStars(){
      const count = 220;
      stars = new Array(count).fill(0).map(()=>({
        x: Math.random()*logicalSize, y: Math.random()*logicalSize,
        size: Math.random()*1.4 + 0.4, opacity: Math.random()*0.5 + 0.2,
        speed: Math.random()*0.16 + 0.05
      }));
    }

    function drawBackground(dt){
      const g = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, radius*1.3);
      g.addColorStop(0, '#171338'); g.addColorStop(1, '#0A0918');
      ctx.fillStyle = g; ctx.fillRect(0,0,logicalSize,logicalSize);

      const px = dt * 0.06;
      for(const s of stars){
        s.x += s.speed*px; if(s.x > logicalSize) s.x = 0;
        ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, TAU);
        ctx.fillStyle = `rgba(255,255,255,${s.opacity})`; ctx.fill();
      }
    }

    // ------- Boundary ring + scanner (adapts to shape) -------
    function drawBoundary(dt){
      ctx.save(); ctx.translate(center.x, center.y);
      scanT = (scanT + dt * 0.00025) % 1;

      if (shape === 'circle'){
        const grad = ctx.createRadialGradient(0,0, radius-8, 0,0, radius+8);
        grad.addColorStop(0,'rgba(99,102,241,0.0)'); grad.addColorStop(0.45,'rgba(99,102,241,0.4)');
        grad.addColorStop(0.75,'rgba(34,211,238,0.6)'); grad.addColorStop(1,'rgba(20,184,166,0.0)');
        ctx.strokeStyle = grad; ctx.lineWidth = 6;
        ctx.beginPath(); ctx.arc(0,0, radius, 0, TAU); ctx.stroke();

        ctx.globalAlpha = .14; ctx.lineWidth = 18; ctx.beginPath();
        ctx.arc(0,0, radius-2, 0, TAU); ctx.stroke(); ctx.globalAlpha = 1;

        const sweep = Math.PI/12, angle = scanT*TAU;
        const a0 = angle - sweep/2, a1 = angle + sweep/2;
        const tipX = Math.cos(angle)*radius, tipY = Math.sin(angle)*radius;
        const lg = ctx.createLinearGradient(0,0, tipX, tipY);
        lg.addColorStop(0,'rgba(34,211,238,0.0)'); lg.addColorStop(0.4,'rgba(99,102,241,0.45)'); lg.addColorStop(1,'rgba(168,85,247,0.9)');
        ctx.strokeStyle = lg; ctx.lineCap='round'; ctx.lineWidth = 8;
        ctx.beginPath(); ctx.arc(0,0, radius, a0, a1); ctx.stroke();
      }
      else if (shape === 'ellipse'){
        const rx = radius, ry = radius*ellipseRatio;
        ctx.strokeStyle = 'rgba(137,180,255,0.65)'; ctx.lineWidth = 6;
        ctx.beginPath(); ctx.ellipse(0,0, rx,ry, 0, 0, TAU); ctx.stroke();

        ctx.globalAlpha=.12; ctx.lineWidth=18; ctx.beginPath();
        ctx.ellipse(0,0, rx-2, ry-2, 0, 0, TAU); ctx.stroke(); ctx.globalAlpha=1;

        const sweep = Math.PI/10, angle = scanT*TAU;
        ctx.strokeStyle = 'rgba(168,85,247,0.95)'; ctx.lineWidth = 7; ctx.lineCap='round';
        ctx.beginPath(); ctx.ellipse(0,0, rx,ry, 0, angle - sweep/2, angle + sweep/2); ctx.stroke();
      }
      else {
        const verts = (shape === 'hexagon')
          ? regularPolygon(6, radius, polyRotation - Math.PI/6)  // flat-top orientation + rotation
          : regularPolygon(4, radius, polyRotation + Math.PI/4); // axis-aligned when 45¬∞

        ctx.strokeStyle = 'rgba(137,180,255,0.65)'; ctx.lineWidth = 6;
        ctx.beginPath(); ctx.moveTo(verts[0].x - center.x, verts[0].y - center.y);
        for (let i=1;i<verts.length;i++) ctx.lineTo(verts[i].x - center.x, verts[i].y - center.y);
        ctx.closePath(); ctx.stroke();

        ctx.globalAlpha = .12; ctx.lineWidth = 18;
        ctx.beginPath(); ctx.moveTo(verts[0].x - center.x, verts[0].y - center.y);
        for (let i=1;i<verts.length;i++) ctx.lineTo(verts[i].x - center.x, verts[i].y - center.y);
        ctx.closePath(); ctx.stroke(); ctx.globalAlpha=1;

        const n = verts.length;
        const edgeIndex = Math.floor(scanT * n);
        const v1 = verts[edgeIndex], v2 = verts[(edgeIndex+1)%n];
        ctx.strokeStyle = 'rgba(168,85,247,0.95)'; ctx.lineWidth=8; ctx.lineCap='round';
        ctx.beginPath(); ctx.moveTo(v1.x - center.x, v1.y - center.y);
        ctx.lineTo(v2.x - center.x, v2.y - center.y); ctx.stroke();
      }
      ctx.restore();
    }

    // ------- Geometry helpers -------
    function regularPolygon(n, R, rot=0){
      const out = [];
      for(let i=0;i<n;i++){
        const a = rot + i * TAU/n;
        out.push({ x: center.x + R*Math.cos(a), y: center.y + R*Math.sin(a) });
      }
      return out;
    }

    // ------- Particles -------
    function createParticles(x,y,color){
      for(let i=0;i<15;i++){
        particles.push({ x,y, dx:(Math.random()-0.5)*90, dy:(Math.random()-0.5)*90, size:Math.random()*2+1, life:1, color });
      }
      if (particles.length > 900) particles.splice(0, particles.length - 900);
    }
    function drawParticles(dt){
      const decay = dt * 0.001;
      for(let i=particles.length-1; i>=0; i--){
        const p = particles[i];
        p.x += p.dx*(dt*0.001); p.y += p.dy*(dt*0.001); p.life -= decay;
        if (p.life <= 0) particles.splice(i,1);
        else {
          ctx.globalAlpha = Math.max(0, p.life);
          ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, TAU);
          ctx.fillStyle = p.color; ctx.fill(); ctx.globalAlpha = 1;
        }
      }
    }

    // ------- Powerups -------
    const PU_RADIUS = 12;
    const PU_TYPES = ['SPEED_UP','SLOW','SCORE_X2','MULTI','SHIELD']; // added MULTI & SHIELD

    function maybeSpawnPowerup(dt){
      spawnTimer -= dt;
      if (spawnTimer <= 0 && powerups.length < 3){
        spawnTimer = 7000 + Math.random()*4000; // 7‚Äì11s
        // spawn near center, push outwards
        const a = Math.random()*TAU; const r = radius*0.20;
        const x = center.x + Math.cos(a)*r; const y = center.y + Math.sin(a)*r;
        const type = PU_TYPES[Math.floor(Math.random()*PU_TYPES.length)];
        const outward = { dx: Math.cos(a) * (30 + Math.random()*40), dy: Math.sin(a) * (30 + Math.random()*40) }; // px/s
        powerups.push({x,y, type, dx: outward.dx, dy: outward.dy, born: performance.now(), ttl: 14000});
      }
      // expire
      const now = performance.now();
      for (let i=powerups.length-1;i>=0;i--){
        if (now - powerups[i].born > powerups[i].ttl) powerups.splice(i,1);
      }
    }

    function drawPowerups(){
      for(const p of powerups){
        ctx.save(); ctx.translate(p.x, p.y); ctx.shadowBlur=12;
        let color = '#a855f7';
        if (p.type==='SPEED_UP') color = '#22d3ee';
        else if (p.type==='SLOW') color = '#fbbf24';
        else if (p.type==='SCORE_X2') color = '#34d399';
        else if (p.type==='MULTI') color = '#60a5fa';
        else if (p.type==='SHIELD') color = '#f472b6';
        ctx.shadowColor = color; ctx.fillStyle = color; ctx.strokeStyle='white'; ctx.lineWidth=1;

        // backdrop
        ctx.beginPath(); ctx.arc(0,0, PU_RADIUS, 0, TAU); ctx.globalAlpha=.12; ctx.fill(); ctx.globalAlpha=1;

        // icon per type
        if (p.type==='SPEED_UP'){ // ‚ö°
          ctx.beginPath(); ctx.moveTo(-5,-8); ctx.lineTo(2,-8); ctx.lineTo(-1,0);
          ctx.lineTo(6,0); ctx.lineTo(0,8); ctx.lineTo(2,0); ctx.lineTo(-5,-8);
          ctx.closePath(); ctx.fill(); ctx.stroke();
        } else if (p.type==='SLOW'){ // pause
          ctx.fillRect(-5,-8,4,16); ctx.fillRect(1,-8,4,16); ctx.strokeRect(-5,-8,4,16); ctx.strokeRect(1,-8,4,16);
        } else if (p.type==='SCORE_X2'){ // star
          ctx.beginPath(); for(let i=0;i<10;i++){ const a=i*TAU/10; const rad=(i%2? 5:9); ctx.lineTo(Math.cos(a)*rad, Math.sin(a)*rad); }
          ctx.closePath(); ctx.fill(); ctx.stroke();
        } else if (p.type==='MULTI'){ // 3 dots
          for (let i=-1;i<=1;i++){ ctx.beginPath(); ctx.arc(i*6,0,2.5,0,TAU); ctx.fill(); }
        } else if (p.type==='SHIELD'){ // ring
          ctx.beginPath(); ctx.arc(0,0,8,0,TAU); ctx.stroke();
          ctx.beginPath(); ctx.arc(0,0,4,0,TAU); ctx.stroke();
        }
        ctx.restore();
      }
    }

    function movePowerups(dt){
      const step = dt * 0.001;
      for(const p of powerups){
        p.x += p.dx * step;
        p.y += p.dy * step;

        // auto-collect when they hit the boundary
        if (touchesBoundary(p.x, p.y, PU_RADIUS*0.7)){
          applyPowerup(p.type);
          createParticles(p.x, p.y, '#ffffff');
          p.autoCollected = true;
        }
      }
      // remove collected
      for (let i=powerups.length-1; i>=0; i--){
        if (powerups[i].autoCollected) powerups.splice(i,1);
      }
    }

    function collectPowerupsByBalls(){
      for (const b of balls){
        for (let i=powerups.length-1; i>=0; i--){
          const p = powerups[i];
          const d = Math.hypot(b.x - p.x, b.y - p.y);
          if (d < b.radius + PU_RADIUS*0.7){
            applyPowerup(p.type);
            createParticles(p.x, p.y, '#ffffff');
            powerups.splice(i,1);
          }
        }
      }
    }

    function applyPowerup(type){
      const now = performance.now();
      let dur = 8000;
      if (type==='SCORE_X2') dur = 12000;
      if (type==='MULTI') dur = 10000;
      if (type==='SHIELD') dur = 0; // shield is single use; store as stack of 1 effect instance

      if (type==='SHIELD'){
        // add one shield charge
        activeEffects.push({type:'SHIELD', until: now + 3600000}); // long until; we remove on consume
      } else {
        // refresh or add timed effect
        const ex = activeEffects.find(e=>e.type===type);
        const until = now + dur;
        if (ex) ex.until = until; else activeEffects.push({type, until});
      }
      updateEffectsUI();
    }

    function tickEffects(){
      const now = performance.now();
      for (let i=activeEffects.length-1;i>=0;i--){
        const e = activeEffects[i];
        if (e.type==='SHIELD') continue; // persists until consumed
        if (now >= e.until) activeEffects.splice(i,1);
      }
      ensureMultiBallActive();
    }

    function updateEffectsUI(){
      const now = performance.now();
      effectsBar.innerHTML = activeEffects.map(e=>{
        let label = e.type==='SPEED_UP' ? '‚ö° Speed +' :
                    e.type==='SLOW' ? 'üê¢ Slow' :
                    e.type==='SCORE_X2' ? '‚≠ê Score x2' :
                    e.type==='MULTI' ? 'üîÆ Multi-ball' :
                    'üõ°Ô∏è Shield';
        const remain = (e.type==='SHIELD') ? '1x' : (Math.max(0, Math.ceil((e.until - now)/1000)) + 's');
        return `<span class="badge">${label} ¬∑ ${remain}</span>`;
      }).join('');
    }

    // ------- Boss -------
    function updateBoss(dt){
      if (!boss) return;
      const step = dt * 0.001;
      boss.angle = (boss.angle + boss.speed*step) % TAU;
      const orbitR = radius * 0.55;
      boss.x = center.x + Math.cos(boss.angle) * orbitR;
      boss.y = center.y + Math.sin(boss.angle) * orbitR;
    }

    function drawBoss(){
      if (!boss) return;
      ctx.save();
      ctx.translate(boss.x, boss.y);
      ctx.shadowColor = 'rgba(244,63,94,0.9)'; ctx.shadowBlur = 20;
      const g = ctx.createRadialGradient(0,0, boss.r*0.2, 0,0, boss.r);
      g.addColorStop(0, 'rgba(244,63,94,1)');
      g.addColorStop(1, 'rgba(244,63,94,0.6)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(0,0, boss.r, 0, TAU); ctx.fill();
      ctx.shadowBlur = 0;

      // crystalline pattern
      ctx.strokeStyle = 'rgba(255,255,255,0.7)'; ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i=0;i<8;i++){
        const a = i*TAU/8; ctx.moveTo(0,0); ctx.lineTo(Math.cos(a)*boss.r, Math.sin(a)*boss.r);
      }
      ctx.stroke();

      ctx.restore();
    }

    function updateBossUI(){
      if (!boss){
        bossPanel.classList.add('hidden');
      } else {
        bossPanel.classList.remove('hidden');
        const pct = clamp(boss.hp / boss.hpMax, 0, 1);
        bossHpBar.style.width = (pct*100).toFixed(1) + '%';
        bossHpLabel.textContent = `${Math.max(0, Math.ceil(boss.hp))} / ${boss.hpMax}`;
      }
    }

    // ------- Boundary tests (for powerup auto-collect) -------
    function touchesBoundary(x, y, r=0){
      if (shape==='circle'){
        const d = Math.hypot(x-center.x, y-center.y);
        return (d + r >= radius - 0.5);
      } else if (shape==='ellipse'){
        const rx = radius, ry = radius*ellipseRatio;
        const nx = (x-center.x)/rx, ny = (y-center.y)/ry;
        const d = Math.hypot(nx, ny); // normalized distance
        // approximate touch: if normalized distance * min(rx,ry) + r >= min(rx,ry)
        return (d * Math.min(rx,ry) + r >= Math.min(rx,ry) - 0.5);
      } else {
        // polygon: outside or on any edge by signed distance
        const n = (shape==='hexagon'?6:4);
        const rot = (shape==='hexagon')?(polyRotation - Math.PI/6):(polyRotation + Math.PI/4);
        const verts = regularPolygon(n, radius, rot);
        for (let i=0;i<n;i++){
          const v1=verts[i], v2=verts[(i+1)%n];
          const ex=v2.x-v1.x, ey=v2.y-v1.y;
          let nx=ey, ny=-ex; const len=Math.hypot(nx,ny)||1; nx/=len; ny/=len;
          const dist = (x - v1.x)*nx + (y - v1.y)*ny;
          if (dist + r > 0) return true; // outside/touching this edge
        }
        return false;
      }
    }

    // ------- Shape-aware boundary collisions -------
    function reflectWithOffset(vx, vy, nx, ny, applyRandom=false){
      let off = boundaryOffsetRad();
      if (applyRandom) off = maybeRandomizeAngle(off);
      const dot = vx*nx + vy*ny;
      let rx = vx - 2*dot*nx, ry = vy - 2*dot*ny;
      const rot = rotateVec(rx, ry, off);
      const set = setMagnitude(rot.dx, rot.dy, effectiveSpeed());
      return set;
    }

    function collideCircleBoundary(b){
      const vx = b.x - center.x, vy = b.y - center.y;
      const dist = Math.hypot(vx, vy);
      if (dist + b.radius <= radius) return false;

      if (dist === 0){
        const a = Math.random()*TAU, sp = effectiveSpeed();
        b.dx = Math.cos(a)*sp; b.dy = Math.sin(a)*sp; return true;
      }
      const nx = vx/dist, ny = vy/dist;
      const rv = reflectWithOffset(b.dx, b.dy, nx, ny, true);
      b.dx = rv.dx; b.dy = rv.dy;
      b.x = center.x + nx*(radius - b.radius - 0.5);
      b.y = center.y + ny*(radius - b.radius - 0.5);
      return true;
    }

    function collideEllipseBoundary(b){
      const rx = radius, ry = radius*ellipseRatio;
      const px = b.x - center.x, py = b.y - center.y;

      const normX = px/rx, normY = py/ry;
      const distNorm = Math.hypot(normX, normY);
      if (distNorm + (b.radius/Math.min(rx,ry)) <= 1) return false;

      let nx = px/(rx*rx), ny = py/(ry*ry);
      const nlen = Math.hypot(nx,ny)||1; nx/=nlen; ny/=nlen;

      const rv = reflectWithOffset(b.dx, b.dy, nx, ny, true);
      b.dx = rv.dx; b.dy = rv.dy;

      const scale = 1/distNorm;
      const bx = center.x + px*scale, by = center.y + py*scale;
      b.x = bx - nx*(b.radius + 0.5);
      b.y = by - ny*(b.radius + 0.5);
      return true;
    }

    function collidePolygonBoundary(b, n, rot){
      const verts = regularPolygon(n, radius, rot);
      let maxPen = -Infinity, hitN = null;

      for(let i=0;i<n;i++){
        const v1 = verts[i], v2 = verts[(i+1)%n];
        const ex=v2.x-v1.x, ey=v2.y-v1.y;
        let nx=ey, ny=-ex; const len=Math.hypot(nx,ny)||1; nx/=len; ny/=len;
        const dist = (b.x - v1.x)*nx + (b.y - v1.y)*ny;
        const pen = dist - (-b.radius);
        if (pen > maxPen){ maxPen = pen; hitN = {nx,ny}; }
      }

      if (maxPen > 0 && hitN){
        b.x -= hitN.nx * (maxPen + 0.5);
        b.y -= hitN.ny * (maxPen + 0.5);
        const rv = reflectWithOffset(b.dx, b.dy, hitN.nx, hitN.ny, true);
        b.dx = rv.dx; b.dy = rv.dy;
        return true;
      }
      return false;
    }

    // ------- Entities / Boss collisions -------
    function collideEntities(b){
      for (let i=entities.length-1; i>=0; i--){
        const e = entities[i]; if(!e.visible) continue;
        const dx = e.x - b.x, dy = e.y - b.y, d = Math.hypot(dx, dy);
        if (d < e.size + b.radius){
          // If shield: consume & pass through (no reflect)
          if (hasShield()){
            consumeShield();
            e.visible = false;
            score += Math.round(10 * effectScoreMultiplier());
            createParticles(b.x, b.y, e.color);
            updateEffectsUI(); updateUI();
            continue;
          }
          e.visible = false;
          score += Math.round(10 * effectScoreMultiplier());
          createParticles(b.x, b.y, e.color);
          updateUI();

          if (d > 0){
            const nx = -dx/d, ny = -dy/d;
            let off = maybeRandomizeAngleOnEntity(0);
            const dot = b.dx*nx + b.dy*ny;
            let rx = b.dx - 2*dot*nx, ry = b.dy - 2*dot*ny;
            const rot = rotateVec(rx, ry, boundaryOffsetRad() + off);
            const set = setMagnitude(rot.dx, rot.dy, effectiveSpeed());
            b.dx = set.dx; b.dy = set.dy;
          } else {
            const a = Math.random()*TAU, sp = effectiveSpeed();
            b.dx = Math.cos(a)*sp; b.dy = Math.sin(a)*sp;
          }
          return true;
        }
      }
      return false;
    }

    function collideBoss(b){
      if (!boss) return false;
      const dx = boss.x - b.x, dy = boss.y - b.y, d = Math.hypot(dx, dy);
      if (d < boss.r + b.radius){
        if (hasShield()){
          consumeShield();
          boss.hp -= 2; // shielded pass does big damage
        } else {
          boss.hp -= 1;
          // reflect
          if (d > 0){
            const nx = -dx/d, ny = -dy/d;
            let off = maybeRandomizeAngleOnEntity(0);
            const dot = b.dx*nx + b.dy*ny;
            let rx = b.dx - 2*dot*nx, ry = b.dy - 2*dot*ny;
            const rot = rotateVec(rx, ry, boundaryOffsetRad() + off);
            const set = setMagnitude(rot.dx, ry = rot.dy, effectiveSpeed()); // fix: setMagnitude expects dx,dy
            // Correcting typo:
            b.dx = set.dx; b.dy = set.dy;
          }
        }
        createParticles(boss.x, boss.y, '#f43f5e');
        if (boss.hp <= 0){
          score += Math.round(200 * effectScoreMultiplier());
          boss = null;
          // Level clears immediately
          levelUp();
        }
        updateBossUI(); updateUI();
        return true;
      }
      return false;
    }

    // ------- Drawing -------
    function drawEntities(){
      for(const e of entities){
        if(!e.visible) continue;
        ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.rotation);
        e.rotation += 0.005; e.pulse = (e.pulse + 0.02) % TAU;
        const scale = 1 + Math.sin(e.pulse)*0.1;

        ctx.shadowColor = e.color; ctx.shadowBlur=10;
        ctx.fillStyle = e.color; ctx.strokeStyle='white'; ctx.lineWidth=1;

        const s = e.size * scale;
        switch(e.type){
          case 0: ctx.beginPath(); ctx.arc(0,0,s,0,TAU); ctx.fill(); break;
          case 1: ctx.fillRect(-s/2, -s/2, s, s); break;
          case 2: ctx.beginPath(); ctx.moveTo(0,-s); ctx.lineTo(s,s); ctx.lineTo(-s,s); ctx.closePath(); ctx.fill(); break;
          case 3:
            ctx.beginPath();
            for(let i=0;i<5;i++){ const a=i*TAU/5; const rr = (i%2? s*0.5:s); ctx.lineTo(Math.cos(a)*rr, Math.sin(a)*rr); }
            ctx.closePath(); ctx.stroke(); break;
        }
        ctx.restore();
      }
      ctx.shadowBlur=0;
    }

    function drawBalls(){
      for(const b of balls){
        ctx.shadowColor = b.color; ctx.shadowBlur=20;
        ctx.beginPath(); ctx.arc(b.x, b.y, b.radius, 0, TAU);
        ctx.fillStyle = b.color; ctx.fill(); ctx.shadowBlur=0;
        if (hasShield()){
          ctx.strokeStyle = 'rgba(244,114,182,0.9)';
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(b.x, b.y, b.radius+3, 0, TAU); ctx.stroke();
        }
      }
    }

    // ------- Update per-frame -------
    function updateBalls(dt){
      const scale = dt * (60/1000);
      for(const b of balls){
        // keep magnitude synced to effects
        const set = setMagnitude(b.dx, b.dy, effectiveSpeed());
        b.dx = set.dx; b.dy = set.dy;

        b.x += b.dx * scale;
        b.y += b.dy * scale;

        // boundary
        if (shape==='circle')   collideCircleBoundary(b);
        else if (shape==='ellipse') collideEllipseBoundary(b);
        else if (shape==='hexagon') collidePolygonBoundary(b, 6, polyRotation - Math.PI/6);
        else if (shape==='square')  collidePolygonBoundary(b, 4, polyRotation + Math.PI/4);

        // boss & entities
        if (!collideBoss(b)) collideEntities(b);
      }

      if (!boss && !entities.some(e=>e.visible)) levelUp();
    }

    // ------- Timer & UI -------
    function updateUI(){
      scoreEl.textContent = score;
      levelEl.textContent = currentLevel;
      speedValueEl.textContent = currentSpeedBase();
      offsetValueEl.textContent = parseInt(offsetSlider.value,10);
      shapeLabel.textContent = shapeSelect.options[shapeSelect.selectedIndex].text;
      randAmtLabel.textContent = parseInt(randAmt.value,10);
      polyRotLabel.textContent = parseInt((polyRotation*180/Math.PI)%360,10);
    }
    function updateTimer(){
      const elapsed = Math.floor((Date.now() - startTime)/1000);
      const mm = String(Math.floor(elapsed/60)).padStart(2,'0');
      const ss = String(elapsed%60).padStart(2,'0');
      timerEl.textContent = `${mm}:${ss}`;
    }

    // ------- Game loop -------
    function gameLoop(ts){
      if (paused){ animationFrameId = requestAnimationFrame(gameLoop); return; }
      const dt = Math.min(50, ts - lastTs || 16.67); lastTs = ts;

      ctx.clearRect(0,0,logicalSize,logicalSize);
      drawBackground(dt);
      drawBoundary(dt);
      drawEntities();
      drawBoss();
      drawParticles(dt);

      maybeSpawnPowerup(dt);
      movePowerups(dt);
      collectPowerupsByBalls();
      tickEffects();
      updateEffectsUI();

      updateBoss(dt);
      updateBalls(dt);

      drawPowerups();
      drawBalls();

      animationFrameId = requestAnimationFrame(gameLoop);
    }

    // ------- Events -------
    speedSlider.addEventListener('input', ()=>{ updateUI(); });
    offsetSlider.addEventListener('input', updateUI);

    shapeSelect.addEventListener('change', (e)=>{
      shape = e.target.value;
      portalWrap.classList.remove('shape-circle','shape-ellipse','shape-hexagon','shape-square');
      portalWrap.classList.add(`shape-${shape}`);
      ellipsePanel.classList.toggle('hidden', shape!=='ellipse');
      fitCanvas(); updateUI();
    });

    ellipseRatioSlider.addEventListener('input', (e)=>{
      ellipseRatio = parseFloat(e.target.value); ellipseRatioValue.textContent = ellipseRatio.toFixed(2);
      if (shape==='ellipse'){ const ryPct = Math.round(ellipseRatio*100); portalWrap.style.clipPath = `ellipse(50% ${ryPct}% at 50% 50%)`; }
    });

    polyRot.addEventListener('input', (e)=>{
      const deg = parseInt(e.target.value,10) || 0;
      polyRotation = (deg * Math.PI/180);
      updateUI();
    });

    randToggle.addEventListener('change', updateUI);
    randAmt.addEventListener('input', updateUI);
    randOnEntity.addEventListener('change', updateUI);

    window.addEventListener('resize', ()=>{ fitCanvas(); loadLevel(currentLevel); });
    window.addEventListener('keydown', (e)=>{
      if(e.code==='Space') paused = !paused;
      else if (e.key.toLowerCase()==='r') init();
    });

    // ------- Boot -------
    window.onload = ()=>{
      fitCanvas();
      startTime = Date.now();
      init();
      setInterval(updateTimer, 1000);
    };
  </script>
</body>
</html>
