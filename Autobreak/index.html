<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Magical Orb Weaver — Circular Portal</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root { color-scheme: dark; }
    body { font-family: 'Inter', sans-serif; overflow: hidden; touch-action: none; }

    /* ---- Circular Portal Frame ---- */
    .portal {
      position: relative;
      border-radius: 9999px;           /* circle */
      overflow: hidden;                /* mask canvas to circle */
      isolation: isolate;              /* keep glows inside stacking context */
      aspect-ratio: 1/1;               /* square that scales responsively */
      box-shadow:
        0 0 0 2px rgba(99,102,241,0.25) inset,   /* thin inner rim */
        0 10px 40px rgba(0,0,0,0.45);            /* drop depth */
    }
    /* Outer animated halo */
    .portal::before,
    .portal::after {
      content: "";
      position: absolute;
      inset: -3%;
      border-radius: 50%;
      z-index: -1;
      filter: blur(20px);
      animation: spin 18s linear infinite;
      background:
        conic-gradient(
          from 0deg,
          rgba(168,85,247,0.0) 0deg,
          rgba(99,102,241,0.9) 60deg,
          rgba(34,211,238,0.9) 140deg,
          rgba(20,184,166,0.9) 220deg,
          rgba(168,85,247,0.9) 300deg,
          rgba(168,85,247,0.0) 360deg
        );
      opacity: 0.55;
    }
    .portal::after {
      inset: -6%;
      filter: blur(40px);
      animation-duration: 28s;
      animation-direction: reverse;
      opacity: 0.35;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    canvas { display:block; width:100%; height:100%; cursor:none; }

    /* HUD chips */
    .chip { font-size: 0.70rem; padding: .35rem .55rem; border-radius: .5rem; background: rgba(31,41,55,.6); color:#d1d5db; }
  </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">
  <div class="w-full max-w-4xl mx-auto">
    <h1 class="text-3xl font-bold text-center mb-4">
      <span class="bg-clip-text text-transparent bg-gradient-to-r from-fuchsia-400 via-indigo-400 to-cyan-300">
        Magical Orb Weaver gpt
      </span>
    </h1>

    <!-- HUD -->
    <div class="grid grid-cols-3 gap-4 mb-4 text-center bg-gray-800/60 p-4 rounded-xl shadow-lg">
      <div>
        <p class="text-sm font-medium text-gray-400">Score</p>
        <p id="score" class="text-2xl font-bold text-emerald-400">0</p>
      </div>
      <div>
        <p class="text-sm font-medium text-gray-400">Level</p>
        <p id="level" class="text-2xl font-bold text-purple-400">1</p>
      </div>
      <div>
        <p class="text-sm font-medium text-gray-400">Time</p>
        <p id="timer" class="text-2xl font-bold text-cyan-400">00:00</p>
      </div>
    </div>

    <!-- Circular viewport -->
    <div id="portalWrap" class="portal mx-auto w-full" style="max-width: min(90vw, 640px);">
      <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Controls -->
    <div class="grid grid-cols-1 mt-5 bg-gray-800/60 p-6 rounded-xl shadow-lg gap-6">
      <div class="w-full md:w-3/4 mx-auto">
        <label for="speed" class="text-sm font-medium text-gray-300">Game Speed:
          <span id="speedValue" class="text-sm font-bold text-white">8</span>
        </label>
        <input id="speed" type="range" min="1" max="20" value="8"
               class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
      </div>

      <div class="w-full md:w-3/4 mx-auto">
        <label for="offset" class="text-sm font-medium text-gray-300">Boundary Offset (°):
          <span id="offsetValue" class="text-sm font-bold text-white">0</span>
        </label>
        <input id="offset" type="range" min="-45" max="45" value="0"
               class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
      </div>

      <div class="flex items-center justify-center gap-2">
        <span class="chip">Space = Pause/Resume</span>
        <span class="chip">R = Reset</span>
        <span class="chip">Levels auto-advance</span>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // UI
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const timerEl = document.getElementById('timer');
    const speedSlider = document.getElementById('speed');
    const speedValueEl = document.getElementById('speedValue');
    const offsetSlider = document.getElementById('offset');
    const offsetValueEl = document.getElementById('offsetValue');

    // Runtime
    let center, logicalSize, radius, dpr = Math.max(1, window.devicePixelRatio || 1);
    let animationFrameId;
    let lastTs = 0;
    let startTime, timerInterval, levelInterval;
    let paused = false;

    // Game state
    let ball, entities, particles, stars, score, currentLevel;

    // ---------- Helpers ----------
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const TAU = Math.PI * 2;

    function rotateVec(dx, dy, rad) {
      const c = Math.cos(rad), s = Math.sin(rad);
      return { dx: dx * c - dy * s, dy: dx * s + dy * c };
    }
    function setMagnitude(dx, dy, mag) {
      const len = Math.hypot(dx, dy) || 1;
      return { dx: (dx / len) * mag, dy: (dy / len) * mag };
    }

    // ---------- Canvas / Resize ----------
    function fitCanvas() {
      const wrap = document.getElementById('portalWrap');
      const cssSize = wrap.clientWidth;        // it's square via aspect-ratio
      logicalSize = Math.floor(cssSize);
      canvas.style.width = logicalSize + 'px';
      canvas.style.height = logicalSize + 'px';
      dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(logicalSize * dpr);
      canvas.height = Math.floor(logicalSize * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);  // draw in CSS pixels

      center = { x: logicalSize / 2, y: logicalSize / 2 };
      // leave room so the inner glowing boundary is visible
      radius = (logicalSize / 2) - 18;

      createStars();
      if (ball) {
        ball.x = center.x; ball.y = center.y;
        ball.radius = Math.max(6, radius * 0.03);
      }
    }

    // ---------- Init / Reset ----------
    function init() {
      score = 0;
      currentLevel = 1;
      particles = [];
      ball = createBall();
      loadLevel(currentLevel);

      startTime = Date.now();
      clearInterval(timerInterval);
      clearInterval(levelInterval);
      timerInterval = setInterval(updateTimer, 1000);
      levelInterval = setInterval(levelUp, 20000);

      paused = false;
      lastTs = performance.now();
      cancelAnimationFrame(animationFrameId);
      animationFrameId = requestAnimationFrame(gameLoop);
      updateUI();
    }

    // ---------- Level / Spawning ----------
    function loadLevel(level) {
      entities = [];
      ball.color = `hsl(${(level * 25) % 360}, 100%, 65%)`;

      const rows = Math.min(15, 3 + Math.floor(level / 5));
      const cols = 12 + Math.floor(level / 4);
      const entityType = Math.floor((level - 1) / 10) % 4;

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (Math.random() > 0.4) {
            const angle = (c / cols) * TAU;
            const dist = radius * 0.18 + (r / rows) * radius * 0.62;
            const x = center.x + Math.cos(angle) * dist;
            const y = center.y + Math.sin(angle) * dist;
            entities.push({
              x, y,
              type: entityType,
              size: Math.max(3, (radius / 30) - (r / 2)),
              color: `hsl(${(r * 20 + c * 5) % 360}, 80%, 70%)`,
              visible: true,
              rotation: 0,
              pulse: Math.random()
            });
          }
        }
      }
      updateUI();
    }

    function levelUp() {
      currentLevel++;
      loadLevel(currentLevel);
    }

    // ---------- Background & Effects ----------
    function createStars() {
      const count = 220;
      stars = new Array(count).fill(0).map(() => ({
        x: Math.random() * logicalSize,
        y: Math.random() * logicalSize,
        size: Math.random() * 1.4 + 0.4,
        opacity: Math.random() * 0.5 + 0.2,
        speed: Math.random() * 0.16 + 0.05
      }));
    }

    function drawBackground(dt) {
      // vignette gradient
      const g = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, radius * 1.3);
      g.addColorStop(0, '#171338');
      g.addColorStop(1, '#0A0918');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, logicalSize, logicalSize);

      // subtle star drift
      const px = dt * 0.06;
      for (const s of stars) {
        s.x += s.speed * px;
        if (s.x > logicalSize) s.x = 0;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, TAU);
        ctx.fillStyle = `rgba(255,255,255,${s.opacity})`;
        ctx.fill();
      }
    }

    // glowing inner boundary ring (also shows the collision circle)
    function drawBoundaryRing() {
      ctx.save();
      ctx.translate(center.x, center.y);
      // soft neon stroke
      const strokeGrad = ctx.createRadialGradient(0,0, radius-8, 0,0, radius+8);
      strokeGrad.addColorStop(0, 'rgba(99,102,241,0.0)');
      strokeGrad.addColorStop(0.45, 'rgba(99,102,241,0.4)');
      strokeGrad.addColorStop(0.75, 'rgba(34,211,238,0.6)');
      strokeGrad.addColorStop(1, 'rgba(20,184,166,0.0)');
      ctx.strokeStyle = strokeGrad;
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, TAU);
      ctx.stroke();

      // faint inner glow band for depth
      ctx.globalAlpha = 0.15;
      ctx.lineWidth = 18;
      ctx.beginPath();
      ctx.arc(0, 0, radius - 2, 0, TAU);
      ctx.stroke();
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    function createParticles(x, y, color) {
      particles ??= [];
      for (let i = 0; i < 15; i++) {
        particles.push({
          x, y,
          dx: (Math.random() - 0.5) * 90,
          dy: (Math.random() - 0.5) * 90,
          size: Math.random() * 2 + 1,
          life: 1,
          color
        });
      }
      if (particles.length > 900) particles.splice(0, particles.length - 900);
    }

    function drawParticles(dt) {
      if (!particles) return;
      const decay = dt * 0.001 * 1.0;
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.dx * (dt * 0.001);
        p.y += p.dy * (dt * 0.001);
        p.life -= decay;
        if (p.life <= 0) {
          particles.splice(i, 1);
        } else {
          ctx.globalAlpha = Math.max(0, p.life);
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, TAU);
          ctx.fillStyle = p.color;
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }
    }

    // ---------- Drawing ----------
    function drawBall() {
      ctx.shadowColor = ball.color;
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, TAU);
      ctx.fillStyle = ball.color;
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawEntities() {
      for (const e of entities) {
        if (!e.visible) continue;
        ctx.save();
        ctx.translate(e.x, e.y);
        ctx.rotate(e.rotation);
        e.rotation += 0.005;
        e.pulse = (e.pulse + 0.02) % TAU;
        const scale = 1 + Math.sin(e.pulse) * 0.1;

        ctx.shadowColor = e.color;
        ctx.shadowBlur = 10;
        ctx.fillStyle = e.color;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;

        const s = e.size * scale;
        switch (e.type) {
          case 0: ctx.beginPath(); ctx.arc(0, 0, s, 0, TAU); ctx.fill(); break;
          case 1: ctx.fillRect(-s / 2, -s / 2, s, s); break;
          case 2:
            ctx.beginPath();
            ctx.moveTo(0, -s); ctx.lineTo(s, s); ctx.lineTo(-s, s);
            ctx.closePath(); ctx.fill();
            break;
          case 3:
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
              const a = (i / 5) * TAU;
              const rr = i % 2 === 0 ? s : s * 0.5;
              ctx.lineTo(Math.cos(a) * rr, Math.sin(a) * rr);
            }
            ctx.closePath(); ctx.stroke();
            break;
        }
        ctx.restore();
      }
      ctx.shadowBlur = 0;
    }

    // ---------- Logic ----------
    function currentSpeed() { return parseInt(speedSlider.value, 10); }
    function boundaryOffsetRad() { return (parseInt(offsetSlider.value, 10) || 0) * (Math.PI / 180); }

    function createBall() {
      const sp = currentSpeed();
      const angle = Math.random() * TAU;
      return {
        x: center.x,
        y: center.y,
        radius: Math.max(6, radius * 0.03),
        dx: Math.cos(angle) * sp,
        dy: Math.sin(angle) * sp,
        color: '#FFFFFF'
      };
    }

    function updateBall(dt) {
      const scale = dt * (60 / 1000);  // normalize speed
      ball.x += ball.dx * scale;
      ball.y += ball.dy * scale;

      // circular wall collision
      const vx = ball.x - center.x;
      const vy = ball.y - center.y;
      const dist = Math.hypot(vx, vy);

      if (dist + ball.radius > radius) {
        if (dist === 0) {
          const a = Math.random() * TAU;
          ball.dx = Math.cos(a) * currentSpeed();
          ball.dy = Math.sin(a) * currentSpeed();
        } else {
          const nx = vx / dist, ny = vy / dist;
          const dot = ball.dx * nx + ball.dy * ny;
          let rx = ball.dx - 2 * dot * nx;
          let ry = ball.dy - 2 * dot * ny;

          // apply user offset (spin) to reflected vector
          const rot = rotateVec(rx, ry, boundaryOffsetRad());
          const mag = currentSpeed();
          const set = setMagnitude(rot.dx, rot.dy, mag);
          ball.dx = set.dx; ball.dy = set.dy;

          // reposition just inside the boundary
          ball.x = center.x + nx * (radius - ball.radius - 0.5);
          ball.y = center.y + ny * (radius - ball.radius - 0.5);
        }
      }

      // entity collisions
      for (let i = entities.length - 1; i >= 0; i--) {
        const e = entities[i];
        if (!e.visible) continue;
        const dx = e.x - ball.x;
        const dy = e.y - ball.y;
        const d = Math.hypot(dx, dy);
        if (d < e.size + ball.radius) {
          e.visible = false;
          score += 10;
          createParticles(ball.x, ball.y, e.color);
          updateUI();

          // reflect off entity center normal
          if (d > 0) {
            const nx = -dx / d, ny = -dy / d;
            const proj = ball.dx * nx + ball.dy * ny;
            let rx = ball.dx - 2 * proj * nx;
            let ry = ball.dy - 2 * proj * ny;
            const set = setMagnitude(rx, ry, currentSpeed());
            ball.dx = set.dx; ball.dy = set.dy;
          } else {
            const a = Math.random() * TAU;
            const sp = currentSpeed();
            ball.dx = Math.cos(a) * sp;
            ball.dy = Math.sin(a) * sp;
          }
          break;
        }
      }

      // next level when cleared
      if (!entities.some(e => e.visible)) levelUp();
    }

    function updateUI() {
      scoreEl.textContent = score;
      levelEl.textContent = currentLevel;
      speedValueEl.textContent = currentSpeed();
      offsetValueEl.textContent = parseInt(offsetSlider.value, 10);
    }

    function updateTimer() {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const mm = String(Math.floor(elapsed / 60)).padStart(2, '0');
      const ss = String(elapsed % 60).padStart(2, '0');
      timerEl.textContent = `${mm}:${ss}`;
    }

    // ---------- Loop ----------
    function gameLoop(ts) {
      if (paused) { animationFrameId = requestAnimationFrame(gameLoop); return; }
      const dt = Math.min(50, ts - lastTs || 16.67);
      lastTs = ts;

      // clear + background
      ctx.clearRect(0, 0, logicalSize, logicalSize);
      drawBackground(dt);
      drawBoundaryRing();
      drawEntities();
      drawParticles(dt);
      updateBall(dt);
      drawBall();

      animationFrameId = requestAnimationFrame(gameLoop);
    }

    // ---------- Events ----------
    speedSlider.addEventListener('input', () => {
      const set = setMagnitude(ball.dx, ball.dy, currentSpeed());
      ball.dx = set.dx; ball.dy = set.dy;
      updateUI();
    });
    offsetSlider.addEventListener('input', updateUI);

    window.addEventListener('resize', () => {
      fitCanvas();
      loadLevel(currentLevel);
    });
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') paused = !paused;
      else if (e.key.toLowerCase() === 'r') init();
    });

    // ---------- Boot ----------
    window.onload = () => {
      fitCanvas();
      startTime = Date.now();
      init();
    };
  </script>
</body>
</html>
