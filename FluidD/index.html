<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Interactive Canvas Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            overscroll-behavior: none;
            background-color: #000;
        }
        #led-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        #controls {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2;
            transition: opacity 0.3s ease-in-out;
            max-height: calc(100vh - 2rem);
            overflow-y: auto;
        }
        /* Custom scrollbar for controls */
        #controls::-webkit-scrollbar { width: 6px; }
        #controls::-webkit-scrollbar-track { background: #4a5568; border-radius: 3px; }
        #controls::-webkit-scrollbar-thumb { background: #a0aec0; border-radius: 3px; }
    </style>
</head>
<body class="bg-black">

    <canvas id="led-canvas"></canvas>

    <!-- Controls Panel -->
    <div id="controls" class="w-full max-w-sm bg-gray-800/80 backdrop-blur-md rounded-xl shadow-2xl p-4 border border-gray-700 text-white">
        <div class="flex justify-between items-center mb-4">
             <h1 class="text-xl font-bold">LED Simulator</h1>
             <button id="toggleControlsBtn" class="p-1 rounded-full hover:bg-gray-700 transition-colors">
                <svg id="control-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 15l-6-6-6 6"/></svg>
             </button>
        </div>
       
        <div id="control-content" class="space-y-4">
            <!-- Mode Selection -->
            <div>
                <label class="block text-sm font-medium text-gray-300 mb-2">Mode</label>
                <div class="grid grid-cols-2 gap-2">
                    <button data-mode="fluid" class="mode-btn bg-teal-500 text-white px-2 py-1.5 text-sm rounded-md shadow">Fluid</button>
                    <button data-mode="game" class="mode-btn bg-gray-600 hover:bg-gray-500 text-white px-2 py-1.5 text-sm rounded-md transition">Puck Game</button>
                </div>
            </div>

            <!-- Visual Settings -->
            <div id="visual-settings" class="space-y-4">
                 <div>
                    <label for="ledSize" class="block text-sm font-medium text-gray-300 mb-1">LED Size (<span id="ledSizeVal">10</span>px)</label>
                    <input type="range" id="ledSize" min="5" max="15" step="1" value="10" class="w-full h-2 accent-teal-500 bg-gray-700 rounded-md cursor-pointer">
                </div>
                 <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">LED Shape</label>
                    <div class="grid grid-cols-2 gap-2">
                         <button data-shape="square" class="shape-btn bg-teal-500 text-white px-2 py-1.5 text-sm rounded-md shadow">Square</button>
                         <button data-shape="circle" class="shape-btn bg-gray-600 hover:bg-gray-500 text-white px-2 py-1.5 text-sm rounded-md transition">Circle</button>
                    </div>
                </div>
                <div>
                    <label for="colorMode" class="block text-sm font-medium text-gray-300 mb-1">Color Mode</label>
                    <select id="colorMode" class="w-full bg-gray-700 text-white border border-gray-600 rounded-md py-1.5 px-2 text-sm focus:outline-none focus:ring-2 focus:ring-teal-500">
                        <option value="single">Single Color</option>
                        <option value="rainbow">Vibrant Rainbow</option>
                        <option value="intensity">Intensity Map</option>
                    </select>
                </div>
                <div id="singleColorPicker">
                    <label for="ledColor" class="block text-sm font-medium text-gray-300 mb-1">Ripple Color</label>
                    <input type="color" id="ledColor" value="#00ff99" class="w-full h-9 p-1 bg-gray-700 border border-gray-600 rounded-md cursor-pointer">
                </div>
                 <div id="intensityPresetPicker" class="hidden">
                    <label for="intensityPreset" class="block text-sm font-medium text-gray-300 mb-1">Intensity Preset</label>
                    <select id="intensityPreset" class="w-full bg-gray-700 text-white border border-gray-600 rounded-md py-1.5 px-2 text-sm focus:outline-none focus:ring-2 focus:ring-teal-500">
                        <option value="ocean">Ocean</option>
                        <option value="magma">Magma</option>
                        <option value="forest">Forest</option>
                    </select>
                </div>
                <div>
                    <label for="damping" class="block text-sm font-medium text-gray-300 mb-1">Damping (<span id="dampingVal">0.985</span>)</label>
                    <input type="range" id="damping" min="0.95" max="0.999" step="0.001" value="0.985" class="w-full h-2 accent-teal-500 bg-gray-700 rounded-md cursor-pointer">
                </div>
                <div>
                    <label for="viscosity" class="block text-sm font-medium text-gray-300 mb-1">Viscosity (<span id="viscosityVal">0.05</span>)</label>
                    <input type="range" id="viscosity" min="0" max="0.4" step="0.01" value="0.05" class="w-full h-2 accent-teal-500 bg-gray-700 rounded-md cursor-pointer">
                </div>
                <div>
                     <label class="block text-sm font-medium text-gray-300 mb-2">Brush</label>
                     <div class="grid grid-cols-2 gap-2">
                        <button data-tool="splash" class="tool-btn bg-teal-500 text-white p-1.5 text-sm rounded-md shadow">Splash</button>
                        <button data-tool="obstacle" class="tool-btn bg-gray-600 hover:bg-gray-500 text-white p-1.5 text-sm rounded-md transition">Wall</button>
                     </div>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">Effects</label>
                     <div class="grid grid-cols-1">
                        <button id="rainBtn" class="bg-gray-600 hover:bg-gray-500 text-white px-2 py-1.5 text-sm rounded-md transition">Toggle Rain</button>
                     </div>
                </div>
            </div>

            <!-- Game Settings -->
            <div id="game-settings" class="hidden space-y-3">
                 <p class="text-sm text-center text-gray-300">Push the puck (<span class="text-red-400 font-bold">Red</span>) into the target (<span class="text-purple-400 font-bold">Purple</span>)!</p>
                 <div class="text-center bg-gray-900/50 p-2 rounded-lg">
                     <span class="text-lg font-bold">Score: <span id="score">0</span></span>
                 </div>
                 <button id="resetGameBtn" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-md transition">New Game</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('led-canvas');
        const ctx = canvas.getContext('2d');
        const controls = {
            panel: document.getElementById('controls'),
            content: document.getElementById('control-content'),
            toggleBtn: document.getElementById('toggleControlsBtn'),
            icon: document.getElementById('control-icon'),
            modeBtns: document.querySelectorAll('.mode-btn'),
            shapeBtns: document.querySelectorAll('.shape-btn'),
            toolBtns: document.querySelectorAll('.tool-btn'),
            rainBtn: document.getElementById('rainBtn'),
            ledSize: document.getElementById('ledSize'),
            ledSizeVal: document.getElementById('ledSizeVal'),
            colorMode: document.getElementById('colorMode'),
            ledColor: document.getElementById('ledColor'),
            singleColorPicker: document.getElementById('singleColorPicker'),
            intensityPresetPicker: document.getElementById('intensityPresetPicker'),
            intensityPreset: document.getElementById('intensityPreset'),
            damping: document.getElementById('damping'),
            dampingVal: document.getElementById('dampingVal'),
            viscosity: document.getElementById('viscosity'),
            viscosityVal: document.getElementById('viscosityVal'),
            visualSettings: document.getElementById('visual-settings'),
            gameSettings: document.getElementById('game-settings'),
            score: document.getElementById('score'),
            resetGameBtn: document.getElementById('resetGameBtn'),
        };

        // --- Global State ---
        let LED_SIZE = 10, LED_SHAPE = 'square', cols, rows;
        let current, previous, obstacles;
        let damping = 0.985, viscosity = 0.05;
        let isMouseDown = false, hue = 0;
        let isRaining = false, rainInterval;
        let currentMode = 'fluid', activeTool = 'splash';

        let activeColor = { r: 0, g: 255, b: 153 };
        const intensityPresets = {
            magma: [{r:20,g:3,b:0},{r:139,g:0,b:0},{r:255,g:100,b:0},{r:255,g:255,b:0},{r:255,g:255,b:200}],
            ocean: [{r:0,g:0,b:50},{r:0,g:50,b:150},{r:0,g:150,b:200},{r:0,g:255,b:255},{r:200,g:255,b:255}],
            forest: [{r:0,g:50,b:10},{r:0,g:100,b:20},{r:50,g:180,b:50},{r:150,g:220,b:80},{r:240,g:255,b:200}]
        };

        const game = { puck: { x: 0, y: 0, vx: 0, vy: 0 }, target: { x: 0, y: 0 }, score: 0 };

        // --- Core Functions ---
        function setup() {
            LED_SIZE = parseInt(controls.ledSize.value);
            cols = Math.floor(window.innerWidth / LED_SIZE);
            rows = Math.floor(window.innerHeight / LED_SIZE);
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            current = Array(rows).fill(0).map(() => new Float32Array(cols).fill(0));
            previous = Array(rows).fill(0).map(() => new Float32Array(cols).fill(0));
            obstacles = Array(rows).fill(0).map(() => Array(cols).fill(false));

            if (currentMode === 'game') resetGame();
        }

        function animate() {
            update();
            render();
            requestAnimationFrame(animate);
        }

        // --- Update & Physics ---
        function update() {
            if (currentMode === 'game') updateGame();
            updateFluid();
        }

        function updateFluid() {
            for (let i = 1; i < rows - 1; i++) {
                for (let j = 1; j < cols - 1; j++) {
                    if (obstacles[i][j]) continue;

                    const neighbors_sum = previous[i-1][j] + previous[i+1][j] + previous[i][j-1] + previous[i][j+1];
                    let wave_val = (neighbors_sum / 2) - current[i][j];
                    wave_val = wave_val * (1 - viscosity) + previous[i][j] * viscosity;
                    current[i][j] = wave_val * damping;
                }
            }
            let temp = previous; previous = current; current = temp;
        }

        function updateGame() {
            const px = Math.floor(game.puck.x), py = Math.floor(game.puck.y);
            if (px > 0 && px < cols-1 && py > 0 && py < rows-1) {
                const forceX = current[py][px+1] - current[py][px-1];
                const forceY = current[py+1][px] - current[py-1][px];
                game.puck.vx -= forceX * 0.1; game.puck.vy -= forceY * 0.1;
            }

            game.puck.vx *= 0.98; game.puck.vy *= 0.98;
            game.puck.x += game.puck.vx; game.puck.y += game.puck.vy;
            
            if (game.puck.x < 0.5) { game.puck.x = 0.5; game.puck.vx *= -0.5; }
            if (game.puck.x > cols - 1.5) { game.puck.x = cols-1.5; game.puck.vx *= -0.5; }
            if (game.puck.y < 0.5) { game.puck.y = 0.5; game.puck.vy *= -0.5; }
            if (game.puck.y > rows - 1.5) { game.puck.y = rows-1.5; game.puck.vy *= -0.5; }
            
            if (Math.hypot(game.puck.x - game.target.x, game.puck.y - game.target.y) < 2) {
                game.score++; controls.score.textContent = game.score;
                previous[game.target.y][game.target.x] = 10;
                spawnTarget();
            }
        }

        // --- Render Function (Canvas) ---
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            hue = (hue + 0.03) % (Math.PI * 2);

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    let r, g, b;
                    let hasContent = true;

                    if (obstacles[i][j]) { [r,g,b] = [74, 85, 104]; }
                    else {
                        const val = current[i][j];
                        const intensity = Math.max(0, Math.min(1, Math.abs(val)));
                        if (intensity < 0.01) { hasContent = false; }
                        else {
                            const mode = controls.colorMode.value;
                            if (mode === 'rainbow') { [r,g,b] = sinebow(hue + val * 5, intensity); }
                            else if (mode === 'intensity') {
                                const preset = intensityPresets[controls.intensityPreset.value];
                                [r,g,b] = getColorFromGradient(intensity, preset);
                            } else {
                                r = activeColor.r*intensity; g = activeColor.g*intensity; b = activeColor.b*intensity;
                            }
                        }
                    }
                    
                    if (hasContent) {
                        ctx.fillStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
                        if (LED_SHAPE === 'circle') {
                            ctx.beginPath();
                            ctx.arc(j * LED_SIZE + LED_SIZE/2, i * LED_SIZE + LED_SIZE/2, LED_SIZE/2.2, 0, Math.PI*2);
                            ctx.fill();
                        } else {
                            ctx.fillRect(j * LED_SIZE, i * LED_SIZE, LED_SIZE - 1, LED_SIZE - 1);
                        }
                    }
                }
            }

            if (currentMode === 'game') {
                ctx.fillStyle = 'rgb(252, 165, 165)';
                ctx.beginPath();
                ctx.arc(game.puck.x * LED_SIZE + LED_SIZE/2, game.puck.y * LED_SIZE + LED_SIZE/2, LED_SIZE/1.5, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = 'rgb(192, 132, 252)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(game.target.x * LED_SIZE + LED_SIZE/2, game.target.y * LED_SIZE + LED_SIZE/2, LED_SIZE, 0, Math.PI*2);
                ctx.stroke();
            }
        }
        
        // --- Game Logic & Helpers ---
        function resetGame() {
            game.score = 0; controls.score.textContent = '0';
            clearFluid();
            game.puck.x = Math.floor(cols / 4); game.puck.y = Math.floor(rows / 2);
            game.puck.vx = 0; game.puck.vy = 0; spawnTarget();
        }
        function spawnTarget() {
            game.target.x = Math.floor(cols*0.75 + Math.random()*(cols*0.2));
            game.target.y = Math.floor(rows*0.2 + Math.random()*(rows*0.6));
        }
        function handleInteraction(e, isTouch=false) {
            const touches = isTouch ? e.touches : [e];
            for (let touch of touches) {
                const col = Math.floor(touch.clientX / LED_SIZE);
                const row = Math.floor(touch.clientY / LED_SIZE);
                if (row>0 && row<rows-1 && col>0 && col<cols-1) {
                    switch(activeTool) {
                        case 'splash': if (!obstacles[row][col]) previous[row][col] = 10; break;
                        case 'obstacle': obstacles[row][col] = !obstacles[row][col]; break;
                    }
                }
            }
        }
        function clearFluid() { for (let i=0; i<rows; i++) { current[i].fill(0); previous[i].fill(0); } }
        function hexToRgb(h) { const r= /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h); return r ? {r:parseInt(r[1],16),g:parseInt(r[2],16),b:parseInt(r[3],16)} : null; }
        function sinebow(p, i) { const r=(Math.sin(p)*127+128)*i,g=(Math.sin(p+Math.PI*2/3)*127+128)*i,b=(Math.sin(p+Math.PI*4/3)*127+128)*i; return [r,g,b]; }
        function getColorFromGradient(i, g) { const s=i*(g.length-1),x=Math.floor(s),f=s-x; if(x>=g.length-1)return[g.at(-1).r,g.at(-1).g,g.at(-1).b]; const c1=g[x],c2=g[x+1]; return [c1.r+(c2.r-c1.r)*f,c1.g+(c2.g-c1.g)*f,c1.b+(c2.b-c1.b)*f]; }

        // --- Event Listeners ---
        function setupEventListeners() {
            window.addEventListener('resize', setup);
            canvas.addEventListener('mousedown', e => { isMouseDown=true; handleInteraction(e); });
            canvas.addEventListener('mouseup', () => isMouseDown=false);
            canvas.addEventListener('mousemove', e => isMouseDown && handleInteraction(e));
            canvas.addEventListener('touchstart', e => { isMouseDown=true; handleInteraction(e,true); e.preventDefault(); }, {passive:false});
            canvas.addEventListener('touchend', () => isMouseDown=false);
            canvas.addEventListener('touchmove', e => { if(isMouseDown){ handleInteraction(e,true); e.preventDefault(); } }, {passive:false});
            controls.toggleBtn.addEventListener('click', () => { const h=controls.content.classList.toggle('hidden'); controls.icon.style.transform=h?'rotate(180deg)':'rotate(0deg)'; });
            controls.modeBtns.forEach(b => b.addEventListener('click', () => { currentMode=b.dataset.mode; controls.modeBtns.forEach(btn => btn.classList.replace('bg-teal-500','bg-gray-600')); b.classList.replace('bg-gray-600','bg-teal-500'); controls.visualSettings.style.display='block'; controls.gameSettings.style.display=currentMode==='game'?'block':'none'; if(currentMode==='game')resetGame();else clearFluid(); }));
            controls.shapeBtns.forEach(b => b.addEventListener('click', () => { LED_SHAPE=b.dataset.shape; controls.shapeBtns.forEach(btn => btn.classList.replace('bg-teal-500','bg-gray-600')); b.classList.replace('bg-gray-600','bg-teal-500'); }));
            controls.toolBtns.forEach(b => b.addEventListener('click', () => { activeTool=b.dataset.tool; controls.toolBtns.forEach(btn => btn.classList.replace('bg-teal-500','bg-gray-600')); b.classList.replace('bg-gray-600','bg-teal-500'); }));
            controls.ledSize.addEventListener('input', e => controls.ledSizeVal.textContent = e.target.value);
            controls.ledSize.addEventListener('change', setup);
            controls.colorMode.addEventListener('change', e => { controls.singleColorPicker.style.display=e.target.value==='single'?'block':'none'; controls.intensityPresetPicker.style.display=e.target.value==='intensity'?'block':'none'; });
            controls.ledColor.addEventListener('input', e => activeColor = hexToRgb(e.target.value));
            controls.damping.addEventListener('input', e => { damping = parseFloat(e.target.value); controls.dampingVal.textContent = damping.toFixed(3); });
            controls.viscosity.addEventListener('input', e => { viscosity = parseFloat(e.target.value); controls.viscosityVal.textContent = viscosity.toFixed(2); });
            controls.resetGameBtn.addEventListener('click', resetGame);

            controls.rainBtn.addEventListener('click', () => {
                isRaining = !isRaining;
                controls.rainBtn.classList.toggle('bg-teal-500');
                controls.rainBtn.classList.toggle('bg-gray-600');
                if (isRaining) {
                    rainInterval = setInterval(() => {
                        if (currentMode === 'fluid') { // Only rain in fluid mode
                            const x = Math.floor(Math.random() * (cols - 2)) + 1;
                            const y = Math.floor(Math.random() * (rows - 2)) + 1;
                            if (!obstacles[y][x]) {
                                previous[y][x] = 5; // A gentle splash
                            }
                        }
                    }, 100); 
                } else {
                    clearInterval(rainInterval);
                }
            });
        }
        
        // --- Initialization ---
        activeColor = hexToRgb(controls.ledColor.value);
        setupEventListeners();
        setup();
        animate();
    </script>
</body>
</html>


