<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cosmic Glider 2D — v0.3 (Tactics + Art Pass)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#030611;color:#e5e7eb;font-family:Inter,system-ui,Segoe UI,Roboto,sans-serif}
  #ui{position:fixed;inset:10px auto auto 10px;z-index:10;display:grid;gap:6px}
  .chip{display:flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:rgba(8,10,20,.6);border:1px solid rgba(255,255,255,.12);backdrop-filter:blur(6px);box-shadow:0 10px 25px rgba(0,0,0,.35);font-size:12px}
  .chip b{font-weight:900;color:#cbd5e1;letter-spacing:.2px}
  #legend{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);font-size:12px;background:rgba(7,9,18,.7);border:1px solid rgba(255,255,255,.12);padding:6px 10px;border-radius:10px}
  canvas{display:block;width:100vw;height:100vh}
</style>
</head>
<body>
  <div id="ui">
    <div class="chip"><b>Lvl</b><span id="uiLevel">1</span>&nbsp;&nbsp;<b>Score</b><span id="uiScore">0</span></div>
    <div class="chip"><b>Rings</b><span id="uiRings">0/0</span>&nbsp;&nbsp;<b>Enemies</b><span id="uiEnemies">0</span>&nbsp;&nbsp;<b>Kills</b><span id="uiKills">0</span></div>
    <div class="chip"><b>Mode</b><span>Autoplay</span>&nbsp;&nbsp;<b>Beam</b><span id="uiBeam">Auto</span>&nbsp;&nbsp;<b>FPS</b><span id="uiFPS">—</span></div>
  </div>
  <div id="legend">2D fighter — Smooth glide to rings • Forward-only fire • Wingmen cover front zone • <b>B</b>=tractor beam • Space=warp burst • Arrows/WASD to nudge</div>
  <canvas id="c"></canvas>
<script>
(function(){
  'use strict';
  // ====== Crash overlay ======
  function crashOverlay(msg){
    try{ const el=document.createElement('div'); el.style.cssText='position:fixed;top:10px;right:10px;z-index:99999;background:#9f1239;color:#fff;padding:6px 10px;border-radius:8px;font:12px/1.2 Inter, sans-serif;max-width:70vw;box-shadow:0 6px 20px rgba(0,0,0,.4)'; el.textContent='JS error: '+msg; document.body.appendChild(el);}catch(_){}}
  window.addEventListener('error',e=>crashOverlay(e.message));

  // ====== Config ======
  const CFG={
    DPR: Math.min(window.devicePixelRatio||1, 2),
    SPEED: 210,
    STAR_L1: 90, STAR_L2: 180, BOKEH: 36,
    ENEMY_WAVE_CHANCE: 0.09,
    ENEMY_WAVE_SIZE:[2,3],
    ENEMY_HP: 3,
    BOLT_SPEED: 640,
    FIRE_COOLDOWN: 90,
    MAX_FIRE_RANGE: 500,
    FORWARD_ZONE_FRAC: 0.2,
    NO_BACK_SHOT: true,
    RINGS_MIN: 15, RINGS_MAX: 30,
    RING_INTERVAL:[2,5],
    RING_RADIUS:[26,38],
    RES_SPAWN_CHANCE: 0.018, // per second
    SHIP_X: 0.5, SHIP_Y: 0.78,
    SHIP_ACC_X: 2.8, SHIP_ACC_Y: 2.2,
    SHIP_DAMP: 0.88,
    SHIP_MAX_VX: 540, SHIP_MAX_VY: 480,
    WING_OFFSET: 44,
    WING_COOLDOWN: 1500,
    // Tractor
    BEAM_AUTO: true,
    BEAM_LEN: 200,
    BEAM_HALF_W: 80,
    BEAM_COOLDOWN: 1200
  };

  // ====== Canvas ======
  const canvas=document.getElementById('c');
  const ctx=canvas.getContext('2d', {alpha:false});
  if(!ctx){ crashOverlay('2D Canvas unavailable'); return; }
  let W=1,H=1; function resize(){ W=canvas.width = Math.max(1, Math.floor(window.innerWidth*CFG.DPR)); H=canvas.height = Math.max(1, Math.floor(window.innerHeight*CFG.DPR)); canvas.style.width=window.innerWidth+'px'; canvas.style.height=window.innerHeight+'px'; }
  window.addEventListener('resize',resize,{passive:true}); resize(); ctx.imageSmoothingEnabled=true;

  // ====== HUD refs ======
  const uiLevel=document.getElementById('uiLevel');
  const uiScore=document.getElementById('uiScore');
  const uiRings=document.getElementById('uiRings');
  const uiEnemies=document.getElementById('uiEnemies');
  const uiKills=document.getElementById('uiKills');
  const uiBeam=document.getElementById('uiBeam');
  const uiFPS=document.getElementById('uiFPS');

  // ====== Helpers ======
  const R=()=>Math.random(); const rand=(a,b)=>a+R()*(b-a); const clamp=(v,a,b)=>Math.max(a,Math.min(b,v)); const lerp=(a,b,t)=>a+(b-a)*t; const nowMs=()=>performance.now();

  // ====== Offscreen textures ======
  function makeBoltTex(){ const w=64,h=192, cn=document.createElement('canvas'); cn.width=w; cn.height=h; const g=cn.getContext('2d'); const grad=g.createLinearGradient(w/2,0,w/2,h); grad.addColorStop(0,'rgba(255,255,255,0)'); grad.addColorStop(0.15,'rgba(182,235,255,0.75)'); grad.addColorStop(0.5,'rgba(125,211,252,1)'); grad.addColorStop(0.85,'rgba(192,132,252,0.75)'); grad.addColorStop(1,'rgba(255,255,255,0)'); g.fillStyle=grad; g.fillRect(w*0.42,0,w*0.16,h); g.globalCompositeOperation='lighter'; const glow=g.createLinearGradient(w/2,0,w/2,h); glow.addColorStop(0,'rgba(125,211,252,0)'); glow.addColorStop(0.5,'rgba(125,211,252,0.35)'); glow.addColorStop(1,'rgba(192,132,252,0)'); g.fillStyle=glow; g.fillRect(0,0,w,h); return cn; }
  const TEX_BOLT=makeBoltTex();
  function makeRingTex(r,thick){ const d=Math.ceil((r+thick)*2); const cn=document.createElement('canvas'); cn.width=cn.height=d; const g=cn.getContext('2d'); g.translate(d/2,d/2); g.lineWidth=thick; g.strokeStyle='rgba(150,242,255,0.9)'; g.shadowColor='rgba(54,209,255,0.9)'; g.shadowBlur=thick*1.8; g.beginPath(); g.arc(0,0,r,0,Math.PI*2); g.stroke(); return cn; }

  // ====== Drawers ======
  function drawShip(x,y,rot,scale){ ctx.save(); ctx.translate(x,y); ctx.rotate(rot); ctx.scale(scale,scale); ctx.globalCompositeOperation='lighter'; const eg=ctx.createRadialGradient(0,28,2,0,28,22); eg.addColorStop(0,'rgba(102,204,255,0.8)'); eg.addColorStop(1,'rgba(102,204,255,0)'); ctx.fillStyle=eg; ctx.beginPath(); ctx.ellipse(0,28,10,18,0,0,6.283); ctx.fill(); ctx.globalCompositeOperation='source-over'; ctx.fillStyle='#c6d0e6'; ctx.strokeStyle='#0f172a'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,-18); ctx.lineTo(12,6); ctx.quadraticCurveTo(0,12,-12,6); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle='#90a8ff'; ctx.beginPath(); ctx.moveTo(0,-12); ctx.quadraticCurveTo(6,-4,0,0); ctx.quadraticCurveTo(-6,-4,0,-12); ctx.fill(); ctx.fillStyle='#9aa7bb'; ctx.beginPath(); ctx.moveTo(-18,0); ctx.lineTo(-6,6); ctx.lineTo(-2,16); ctx.lineTo(-22,10); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(18,0); ctx.lineTo(6,6); ctx.lineTo(2,16); ctx.lineTo(22,10); ctx.closePath(); ctx.fill(); ctx.fillStyle='#6f6cf8'; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(3,12); ctx.lineTo(-3,12); ctx.closePath(); ctx.fill(); ctx.restore(); }

  function drawEnemy(x,y,t){ // sleek fighter with fins + glow
    ctx.save(); ctx.translate(x,y); ctx.rotate(Math.sin((t+y)*0.01)*0.04);
    ctx.globalCompositeOperation='lighter'; const g=ctx.createRadialGradient(0,16,2,0,16,18); g.addColorStop(0,'rgba(255,120,150,0.7)'); g.addColorStop(1,'rgba(255,120,150,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.ellipse(0,16,8,12,0,0,6.283); ctx.fill(); ctx.globalCompositeOperation='source-over';
    ctx.fillStyle='#ffb4c1'; ctx.strokeStyle='rgba(128,30,60,0.8)'; ctx.lineWidth=2; // body
    ctx.beginPath(); ctx.moveTo(0,-14); ctx.lineTo(10,6); ctx.quadraticCurveTo(0,10,-10,6); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle='#7b2942'; ctx.beginPath(); ctx.moveTo(0,-10); ctx.quadraticCurveTo(5,-4,0,0); ctx.quadraticCurveTo(-5,-4,0,-10); ctx.fill(); // canopy
    // side fins
    ctx.fillStyle='#ff87a0'; ctx.beginPath(); ctx.moveTo(-16,2); ctx.lineTo(-4,8); ctx.lineTo(-6,14); ctx.lineTo(-20,10); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(16,2); ctx.lineTo(4,8); ctx.lineTo(6,14); ctx.lineTo(20,10); ctx.closePath(); ctx.fill();
    ctx.restore();
  }

  function drawWingman(x,y,t){ // tiny escort craft with animated fin
    ctx.save(); ctx.translate(x,y); ctx.rotate(Math.sin(t*3)*0.1); ctx.fillStyle='#c7d2fe'; ctx.strokeStyle='#1e293b'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(0,-9); ctx.lineTo(8,7); ctx.quadraticCurveTo(0,11,-8,7); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle='#8aa2ff'; ctx.beginPath(); ctx.moveTo(0,-6); ctx.quadraticCurveTo(4,-2,0,0); ctx.quadraticCurveTo(-4,-2,0,-6); ctx.fill();
    ctx.restore();
  }

  function drawShard(x,y,rot){ // resource shard
    ctx.save(); ctx.translate(x,y); ctx.rotate(rot); ctx.globalCompositeOperation='lighter';
    const g=ctx.createLinearGradient(-8,-8,8,8); g.addColorStop(0,'#5eead4'); g.addColorStop(1,'#a7f3d0'); ctx.fillStyle=g; ctx.strokeStyle='rgba(16,94,84,0.5)'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(0,-10); ctx.lineTo(8,0); ctx.lineTo(0,10); ctx.lineTo(-8,0); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.restore();
  }

  // ====== State ======
  let level=1, score=0, kills=0;
  let ringsCleared=0, ringsGoal=0; let nextRingAt=0;
  let bullets=[], enemies=[], rings=[], starsNear=[], starsFar=[], bokeh=[], effects=[], shards=[];
  let nebulas=[], planets=[]; let targetRing=null;
  let wingmen=[{state:'dock',cool:0,x:0,y:0,target:-1,fireCd:0,side:-1,pref:-1},{state:'dock',cool:0,x:0,y:0,target:-1,fireCd:0,side:1,pref:-1}];
  let ship={x:W*CFG.SHIP_X,y:H*CFG.SHIP_Y, vx:0, vy:0, rot:0, fireCd:0, warp:0};
  let input={left:0,right:0,up:0,down:0};
  let beam={auto:CFG.BEAM_AUTO, active:false, cd:0};

  // ====== Level / HUD ======
  function resetLevel(){ ringsCleared=0; ringsGoal = Math.floor(rand(CFG.RINGS_MIN, CFG.RINGS_MAX+1)); nextRingAt = nowMs() + rand(CFG.RING_INTERVAL[0],CFG.RING_INTERVAL[1])*1000; rings.length=0; enemies.length=0; bullets.length=0; effects.length=0; targetRing=null; uiLevel.textContent=level; updateHUD(); }
  function updateHUD(){ uiScore.textContent=score; uiRings.textContent=`${ringsCleared}/${ringsGoal}`; uiEnemies.textContent=enemies.length; uiKills.textContent=kills; uiBeam.textContent=(beam.auto? 'Auto' : (beam.active? 'On':'Off')); }

  // Background stars (DoF)
  function makeStars(arr,count,speed){ arr.length=0; for(let i=0;i<count;i++){arr.push({x:R()*W,y:R()*H,s:speed*(0.7+R()*0.6)})} }
  function makeBokeh(arr,count){ arr.length=0; for(let i=0;i<count;i++){ arr.push({x:R()*W,y:R()*H,r:rand(1.2,2.8),blur:rand(3,10),a:rand(0.25,0.55)}) } }
  function regenStars(){ makeStars(starsFar, CFG.STAR_L1, 0.35); makeStars(starsNear, CFG.STAR_L2, 0.9); makeBokeh(bokeh, CFG.BOKEH); }
  regenStars();

  // Input
  window.addEventListener('keydown',e=>{ if(e.repeat) return; if(e.code==='ArrowLeft'||e.code==='KeyA') input.left=1; if(e.code==='ArrowRight'||e.code==='KeyD') input.right=1; if(e.code==='ArrowUp'||e.code==='KeyW') input.up=1; if(e.code==='ArrowDown'||e.code==='KeyS') input.down=1; if(e.code==='Space'){ ship.warp=1; } if(e.code==='KeyB'){ beam.active=!beam.active; beam.auto=false; updateHUD(); } });
  window.addEventListener('keyup',e=>{ if(e.code==='ArrowLeft'||e.code==='KeyA') input.left=0; if(e.code==='ArrowRight'||e.code==='KeyD') input.right=0; if(e.code==='ArrowUp'||e.code==='KeyW') input.up=0; if(e.code==='ArrowDown'||e.code==='KeyS') input.down=0; });

  // Spawners
  function spawnRing(){ const r=rand(CFG.RING_RADIUS[0],CFG.RING_RADIUS[1]); const tex=makeRingTex(r, Math.max(5, r*0.22)); rings.push({x:rand(W*0.12,W*0.88), y:-r-20, r, tex}); }
  function spawnEnemyWave(){ const n=Math.floor(rand(CFG.ENEMY_WAVE_SIZE[0],CFG.ENEMY_WAVE_SIZE[1]+1)); for(let i=0;i<n;i++){ enemies.push({x:rand(W*0.12,W*0.88), y:-40-i*30, vx:rand(-40,40), vy:rand(120,160), hp:CFG.ENEMY_HP, phase:rand(0,6.28), ttl:10000}); } }
  function spawnShard(){ shards.push({x:rand(W*0.12,W*0.88), y:-20, vx:rand(-20,20), vy:rand(40,80), rot:R()*6.28}); }
  function fireBolt(x,y,tx,ty,from){ const dx=tx-x, dy=ty-y; const len=Math.hypot(dx,dy)||1; const vx=dx/len*CFG.BOLT_SPEED, vy=dy/len*CFG.BOLT_SPEED; bullets.push({x,y,vx,vy,life:900, from}); }

  // Targeting
  function pickNextRing(){ let best=null, bestDy=1e9; for(const r of rings){ const dy=r.y-ship.y; if(dy>-80 && dy<bestDy){ bestDy=dy; best=r; } } targetRing = best || null; }

  // Wingmen
  function updateWingman(w,dt){ w.cool=Math.max(0,w.cool-dt); w.fireCd=Math.max(0,w.fireCd-dt); const dockX=ship.x + w.side*CFG.WING_OFFSET, dockY=ship.y+8; if(w.state==='dock'){ w.x=dockX; w.y=dockY; if(enemies.length>=2 && w.cool<=0) { w.state='launch'; } } else if(w.state==='launch'){ w.x=lerp(w.x||dockX,dockX,0.07); w.y=lerp(w.y||dockY,ship.y-70,0.07); if(Math.abs((w.y||dockY)-(ship.y-70))<5){ w.state='attack'; w.target=-1; } } else if(w.state==='attack'){ if(enemies.length<=1){ w.state='return'; } else { if(w.target<0 || w.target>=enemies.length){ let best=1e9, idx=-1; for(let j=0;j<enemies.length;j++){const e=enemies[j]; const sidePenalty = (((e.x<ship.x)?-1:1)===w.side) ? 0 : 180; const d=Math.hypot(e.x-(w.x||dockX),e.y-(w.y||dockY)) + sidePenalty; if(d<best){best=d; idx=j;} } w.target=idx; } const t=enemies[w.target]; if(!t){ w.state='return'; } else { w.x=lerp(w.x,t.x+(w.side*26),0.1); w.y=lerp(w.y,t.y-24,0.1); if(w.fireCd<=0){ fireBolt(w.x,w.y,t.x,t.y,'wing'); w.fireCd=200; } if(t.y>ship.y+120){ w.state='return'; } } } } else if(w.state==='return'){ w.x=lerp(w.x,dockX,0.1); w.y=lerp(w.y,dockY,0.1); if(Math.hypot(w.x-dockX,w.y-dockY)<4){ w.state='cool'; w.cool=CFG.WING_COOLDOWN; } } else if(w.state==='cool'){ w.x=dockX; w.y=dockY; if(w.cool<=0) { w.state='dock'; } } }

  // ====== Loop ======
  let lastT=nowMs(), accFps=0, frames=0; resetLevel();
  function tick(){ const t=nowMs(); let dt=Math.min(60, t-lastT); lastT=t; const dtSec=dt/1000;

    // Spawns & selection
    if(t>=nextRingAt){ spawnRing(); nextRingAt = t + rand(CFG.RING_INTERVAL[0],CFG.RING_INTERVAL[1])*1000; }
    if(!targetRing || rings.indexOf(targetRing)===-1 || targetRing.y>ship.y+60){ pickNextRing(); }
    if(R() < CFG.ENEMY_WAVE_CHANCE * dt/1000) spawnEnemyWave();
    if(R() < CFG.RES_SPAWN_CHANCE * dt/1000) spawnShard();

    // Movement (glide)
    const desiredX = targetRing? targetRing.x : W*0.5;
    const desiredY = targetRing? clamp(targetRing.y+40, H*0.35, H*0.85) : H*0.7;
    const nudgeX=(input.right-input.left)*180, nudgeY=(input.down-input.up)*120;
    ship.vx += ((desiredX - ship.x)*CFG.SHIP_ACC_X + nudgeX)*dtSec; ship.vy += ((desiredY - ship.y)*CFG.SHIP_ACC_Y + nudgeY)*dtSec;
    ship.vx = clamp(ship.vx, -CFG.SHIP_MAX_VX, CFG.SHIP_MAX_VX); ship.vy = clamp(ship.vy, -CFG.SHIP_MAX_VY, CFG.SHIP_MAX_VY);
    ship.vx *= CFG.SHIP_DAMP; ship.vy *= CFG.SHIP_DAMP; ship.x += ship.vx*dtSec; ship.y += ship.vy*dtSec;
    ship.x=clamp(ship.x, W*0.08, W*0.92); ship.y=clamp(ship.y, H*0.2, H*0.9); ship.rot = lerp(ship.rot, clamp(ship.vx,-260,260)/1000, 0.2);

    const scroll = (CFG.SPEED + (ship.warp? 200:0)) * dtSec; ship.warp=0;

    // Stars
    const starStep=(arr, mul)=>{ for(const s of arr){ s.y+=scroll*mul; if(s.y>H) { s.y=0; s.x=R()*W; } } };
    starStep(starsFar,0.25); starStep(starsNear,0.8);
    for(const bk of bokeh){ bk.y += scroll*0.18; if(bk.y>H){ bk.y=0; bk.x=R()*W; } }

    // Rings
    for(let i=rings.length-1;i>=0;i--){ const r=rings[i]; r.y+=scroll*0.8; const d=Math.hypot(r.x-ship.x, r.y-ship.y); if(d < r.r*0.85){ rings.splice(i,1); ringsCleared++; score+=10; updateHUD(); if(ringsCleared>=ringsGoal){ level++; resetLevel(); } } else if(r.y-r.r>H+60){ rings.splice(i,1); } }

    // Enemies
    for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.ttl-=dt; const sway = Math.sin((t+e.phase*1000)/400)*40; e.x += (e.vx*dtSec) + (sway*dtSec); e.y += (e.vy*dtSec) + (scroll*0.25); if(e.y>ship.y-120) e.vy = Math.max(e.vy, 220); if(e.x<20||e.x>W-20) e.vx*=-1; if(e.y>H+60 || e.ttl<=0){ enemies.splice(i,1); continue; } }

    // Threat assignment to wingmen (front zone)
    const forwardFenceY = ship.y - H*CFG.FORWARD_ZONE_FRAC;
    for(let j=0;j<enemies.length;j++){ const e=enemies[j]; if(e.y>forwardFenceY && e.y<ship.y){ const idx = (e.x<ship.x)? 0 : 1; const w=wingmen[idx]; if((w.state==='dock'||w.state==='cool') && w.cool<=0){ w.state='launch'; w.pref=j; } } }

    // Player auto fire (forward-only + range)
    let aim=null, best=1e9, anyAhead=false, farAhead=false;
    for(const e of enemies){ const dy = ship.y - e.y; if(dy>0){ anyAhead=true; const d=Math.hypot(e.x-ship.x,e.y-ship.y); if(d<=CFG.MAX_FIRE_RANGE){ if(d<best){ best=d; aim=e; } } else { farAhead=true; } } }
    ship.fireCd = (ship.fireCd||0) - dt; if(aim && ship.fireCd<=0){ if(!CFG.NO_BACK_SHOT || aim.y < ship.y){ fireBolt(ship.x, ship.y-20, aim.x, aim.y, 'player'); ship.fireCd=CFG.FIRE_COOLDOWN; } }
    if(!aim && anyAhead && farAhead){ for(const w of wingmen){ if((w.state==='dock'||w.state==='cool') && w.cool<=0){ w.state='launch'; } } }

    // Wingmen update
    for(let i=0;i<wingmen.length;i++){ updateWingman(wingmen[i],dt); }

    // Bullets
    for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dtSec; b.y+=b.vy*dtSec - scroll*0.05; b.life-=dt; if(b.life<=0||b.x<-60||b.x>W+60||b.y<-100||b.y>H+100){ bullets.splice(i,1); continue; } for(let j=enemies.length-1;j>=0;j--){ const e=enemies[j]; const d2=(e.x-b.x)*(e.x-b.x)+(e.y-b.y)*(e.y-b.y); if(d2<22*22){ enemies[j].hp--; bullets.splice(i,1); score+=15; if(enemies[j].hp<=0){ enemies.splice(j,1); kills++; updateHUD(); effects.push({x:e.x,y:e.y,t:260}); } break; } } }

    // Shards (resources) + tractor beam
    beam.cd=Math.max(0,beam.cd-dt);
    if(beam.auto && shards.length>0 && beam.cd<=0){ beam.active=true; }
    for(let i=shards.length-1;i>=0;i--){ const s=shards[i]; s.x+=s.vx*dtSec; s.y+=s.vy*dtSec + scroll*0.4; s.rot += 0.02; // pull if in cone
      if(beam.active){ const bx=ship.x, by=ship.y-8; const dx=s.x-bx, dy=s.y-by; if(dy<0 && -dy<CFG.BEAM_LEN){ const half = CFG.BEAM_HALF_W * (-dy/CFG.BEAM_LEN); if(Math.abs(dx) < half){ // inside cone
            s.x = lerp(s.x, bx, 0.16); s.y = lerp(s.y, by, 0.16);
            if(Math.hypot(s.x-bx,s.y-by)<12){ shards.splice(i,1); score+=25; updateHUD(); continue; }
      } } }
      if(s.y>H+40){ shards.splice(i,1); }
    }
    if(beam.active){ beam.cd = CFG.BEAM_COOLDOWN; }

    // Effects decay
    for(let i=effects.length-1;i>=0;i--){ effects[i].t-=dt; if(effects[i].t<=0) effects.splice(i,1); }

    // ====== Render ======
    ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,W,H);
    // Depthy background: gradient, nebulas, planets, far stars, bokeh, near stars
    const bg=ctx.createLinearGradient(0,0,0,H); bg.addColorStop(0,'#050a1a'); bg.addColorStop(1,'#020612'); ctx.fillStyle=bg; ctx.fillRect(0,0,W,H);
    if(nebulas.length<2 && R()<0.002*dt){ nebulas.push({x:rand(W*0.1,W*0.9), y:-200, r:rand(180,280), s:rand(10,20)}); }
    for(let i=nebulas.length-1;i>=0;i--){ const n=nebulas[i]; n.y += (scroll*0.1) + n.s*(dtSec*0.2); if(n.y-n.r>H){ nebulas.splice(i,1); continue; } const g=ctx.createRadialGradient(n.x,n.y,0,n.x,n.y,n.r); g.addColorStop(0,'rgba(100,180,255,0.08)'); g.addColorStop(1,'rgba(100,180,255,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(n.x,n.y,n.r,0,6.283); ctx.fill(); }
    if(planets.length<1 && R()<0.0015*dt){ planets.push({x:rand(W*0.2,W*0.8), y:-160, r:rand(60,120), s:rand(18,28)}); }
    for(let i=planets.length-1;i>=0;i--){ const p=planets[i]; p.y += (scroll*0.15) + p.s*dtSec; if(p.y-p.r>H+80){ planets.splice(i,1); continue; } const gp=ctx.createRadialGradient(p.x,p.y,p.r*0.1,p.x,p.y,p.r); gp.addColorStop(0,'rgba(255,255,255,0.18)'); gp.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=gp; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,6.283); ctx.fill(); }
    // far stars
    ctx.fillStyle='rgba(170,190,255,0.6)'; for(const s of starsFar){ ctx.fillRect(s.x|0, s.y|0, 1,1); }
    // bokeh (defocus)
    for(const bk of bokeh){ ctx.save(); ctx.shadowBlur=bk.blur; ctx.shadowColor='rgba(170,190,255,'+bk.a+')'; ctx.fillStyle='rgba(170,190,255,0)'; ctx.beginPath(); ctx.arc(bk.x,bk.y,bk.r,0,6.283); ctx.fill(); ctx.restore(); }
    // near stars
    ctx.fillStyle='rgba(220,230,255,0.95)'; for(const s of starsNear){ ctx.fillRect(s.x|0, s.y|0, 1,1); }

    // rings
    for(const r of rings){ const x=(r.x - r.tex.width/2)|0, y=(r.y - r.tex.height/2)|0; ctx.drawImage(r.tex, x, y); }

    // shards (resources)
    for(const s of shards){ drawShard(s.x,s.y,s.rot); }

    // enemies
    const tt=t/1000; for(const e of enemies){ drawEnemy(e.x,e.y,tt); }

    // bullets
    ctx.save(); ctx.globalCompositeOperation='lighter'; for(const b of bullets){ const a=Math.atan2(b.vy,b.vx) - Math.PI/2; ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(a); ctx.drawImage(TEX_BOLT, -TEX_BOLT.width/2, -TEX_BOLT.height*0.55, TEX_BOLT.width, TEX_BOLT.height*0.9); ctx.restore(); } ctx.restore();

    // effects
    for(const fx of effects){ const k=fx.t/260; ctx.save(); ctx.globalCompositeOperation='lighter'; const g=ctx.createRadialGradient(fx.x,fx.y,0,fx.x,fx.y,36); g.addColorStop(0,'rgba(255,255,255,'+(0.6*k)+')'); g.addColorStop(1,'rgba(255,255,255,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(fx.x,fx.y,36*(1.2-k*0.2),0,6.283); ctx.fill(); ctx.restore(); }

    // tractor beam visual
    if(beam.active){ const bx=ship.x, by=ship.y-8; const len=CFG.BEAM_LEN, half=CFG.BEAM_HALF_W; ctx.save(); ctx.globalCompositeOperation='lighter'; const grad=ctx.createLinearGradient(bx,by, bx, by-len); grad.addColorStop(0,'rgba(125,211,252,0.35)'); grad.addColorStop(1,'rgba(192,132,252,0.0)'); ctx.fillStyle=grad; ctx.beginPath(); ctx.moveTo(bx,by); ctx.lineTo(bx-half,by-len); ctx.lineTo(bx+half,by-len); ctx.closePath(); ctx.fill(); ctx.restore(); beam.active=false; }

    // wingmen & ship
    drawWingman(wingmen[0].x||ship.x-44, wingmen[0].y||ship.y+8, tt); drawWingman(wingmen[1].x||ship.x+44, wingmen[1].y||ship.y+8, tt);
    drawShip(ship.x, ship.y, ship.rot, 1);

    // HUD/FPS
    updateHUD(); frames++; accFps+=dt; if(accFps>250){ uiFPS.textContent=String(Math.round(1000/(accFps/frames))); accFps=0; frames=0; }
    requestAnimationFrame(tick);
  }

  // First paint to avoid flash-of-empty
  (function firstPaint(){ ctx.fillStyle='#070a18'; ctx.fillRect(0,0,W,H); ctx.fillStyle='rgba(255,255,255,.7)'; ctx.fillRect(W/2-1,H/2-1,2,2); })();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
