<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cosmic Glider 2D ‚Äî v1.1 (AI &amp; Ship Constraints)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #030611;
      --panel: rgba(8, 10, 20, .78);
      --panel2: rgba(10, 14, 28, .9);
      --br: rgba(255, 255, 255, .14);
      --ink: #e5e7eb;
      --mut: #cbd5e1;
      --neon: rgba(110, 231, 183, 0.9);
    }

    html,
    body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: var(--bg);
      color: var(--ink);
      font-family: Inter, system-ui, Segoe UI, Roboto, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      outline: none;
    }

    /* HUD */
    #ui {
      position: fixed;
      inset: 10px auto auto 10px;
      z-index: 12;
      display: grid;
      gap: 6px;
    }

    .chip {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: var(--panel);
      border: 1px solid var(--br);
      backdrop-filter: blur(8px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, .35);
      font-size: 12px;
      text-shadow: 0 1px 0 rgba(0, 0, 0, .5);
    }

    .chip b {
      font-weight: 900;
      color: var(--mut);
      letter-spacing: .2px;
    }

    #menuBtn {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 14;
      background: var(--panel2);
      border: 1px solid var(--br);
      padding: 10px 14px;
      border-radius: 12px;
      font-weight: 900;
      cursor: pointer;
      box-shadow: 0 12px 28px rgba(0, 0, 0, .45);
      color: var(--ink);
    }

    /* Modal Overlays (Menu & Summary) */
    .modal {
      position: fixed;
      inset: 0;
      z-index: 20;
      display: none;
      align-items: center;
      justify-content: center;
      background: radial-gradient(1200px 700px at 50% 20%, rgba(30, 41, 59, .45), rgba(2, 6, 18, .94));
      animation: fadeIn .3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    .modal.open {
      display: flex;
    }

    .modal .wrap {
      position: relative;
      display: grid;
      gap: 16px;
      width: min(980px, 92vw);
      color: var(--ink);
      text-align: center;
    }

    .modal h1 {
      margin: 0 0 6px;
      font-size: 26px;
      letter-spacing: .3px;
    }

    /* Menu Specifics */
    .cards {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 14px;
      text-align: left;
    }

    .card {
      position: relative;
      background: var(--panel2);
      border: 1px solid var(--br);
      border-radius: 16px;
      padding: 14px;
      cursor: pointer;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0, 0, 0, .45);
      color: var(--ink);
      transition: transform .2s, box-shadow .2s;
    }

    .card:hover {
      transform: translateY(-2px);
    }

    .card.selected {
      border-color: var(--neon);
      box-shadow: 0 0 20px rgba(110, 231, 183, 0.4), 0 10px 40px rgba(0, 0, 0, .5);
    }

    .card .title {
      font-weight: 900;
      margin-bottom: 4px;
    }

    .card .desc {
      font-size: 12px;
      opacity: .95;
    }

    .card .tag {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 11px;
      font-weight: 800;
      background: linear-gradient(90deg, #6ee7ff, #a78bfa);
      color: #0b1020;
      padding: 2px 8px;
      border-radius: 999px;
    }

    .stars {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .stars span {
      position: absolute;
      width: 2px;
      height: 2px;
      background: #fff;
      opacity: .75;
      box-shadow: 0 0 8px rgba(180, 200, 255, .9);
      filter: blur(.3px);
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
    }

    .btn {
      background: rgba(255, 255, 255, .08);
      border: 1px solid rgba(255, 255, 255, .22);
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 800;
      cursor: pointer;
      color: var(--ink);
    }

    .primary {
      background: linear-gradient(90deg, #6ee7ff, #a78bfa);
      color: #0b1020;
      border: none;
      box-shadow: 0 12px 30px rgba(124, 58, 237, .35);
    }

    /* Level Summary Graph */
    #summaryChart {
      display: flex;
      justify-content: center;
      align-items: flex-end;
      gap: 24px;
      margin: 20px 0;
      height: 150px;
      border-bottom: 1px solid var(--br);
      padding-bottom: 10px;
    }

    .bar-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
      max-width: 100px;
    }

    .bar {
      width: 100%;
      background: linear-gradient(to top, #6ee7ff, #a78bfa);
      border-radius: 8px 8px 0 0;
      height: 0;
      transition: height 1s ease-out;
    }

    .bar-label {
      font-size: 12px;
      opacity: 0.8;
      margin-top: 8px;
    }

    .bar-value {
      font-size: 18px;
      font-weight: 900;
      margin-top: 4px;
    }

    #summaryNextLevel {
      font-size: 14px;
      opacity: 0.9;
    }

    /* On-screen controls */
    #pad {
      position: fixed;
      left: 12px;
      bottom: 12px;
      z-index: 13;
      width: 132px;
      height: 132px;
      border-radius: 50%;
      background: radial-gradient(closest-side, rgba(255, 255, 255, .06), rgba(255, 255, 255, .02));
      border: 1px solid var(--br);
      backdrop-filter: blur(6px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, .35);
    }

    #pad:after {
      content: "";
      position: absolute;
      inset: 8px;
      border-radius: 50%;
      border: 1px dashed rgba(255, 255, 255, .18);
    }

    #stick {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 44px;
      height: 44px;
      margin: -22px;
      border-radius: 50%;
      background: rgba(255, 255, 255, .2);
      border: 1px solid rgba(255, 255, 255, .28);
      box-shadow: 0 6px 18px rgba(0, 0, 0, .35);
      transition: transform 0.1s;
    }

    #actions {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 13;
      display: grid;
      gap: 10px;
    }

    .act {
      min-width: 140px;
      background: var(--panel2);
      border: 1px solid var(--br);
      padding: 12px 14px;
      border-radius: 12px;
      font-weight: 900;
      cursor: pointer;
      box-shadow: 0 12px 28px rgba(0, 0, 0, .45);
      color: var(--ink);
    }

    .act:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .tagline {
      position: fixed;
      left: 50%;
      bottom: 10px;
      transform: translateX(-50%);
      z-index: 11;
      background: var(--panel);
      border: 1px solid var(--br);
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 12px;
      text-shadow: 0 1px 0 rgba(0, 0, 0, .6);
      color: var(--ink);
    }
  </style>
</head>

<body>
  <button id="menuBtn" aria-label="Open Cosmic Menu">‚òÑÔ∏è Cosmic Menu</button>

  <div id="ui">
    <div class="chip"><b>Mode</b><span id="uiMode">&nbsp;B ‚Ä¢ Balanced</span>&nbsp;&nbsp;<b>Lvl</b><span
        id="uiLevel">&nbsp;1</span>&nbsp;&nbsp;<b>Score</b><span id="uiScore">&nbsp;0</span></div>
    <div class="chip"><b>Rings</b><span id="uiRings">&nbsp;0/0</span>&nbsp;&nbsp;<b>Enemies</b><span
        id="uiEnemies">&nbsp;0</span>&nbsp;&nbsp;<b>Kills</b><span id="uiKills">&nbsp;0</span></div>
    <div class="chip"><b>Beam</b><span id="uiBeam">&nbsp;Auto</span>&nbsp;&nbsp;<b>FPS</b><span
        id="uiFPS">&nbsp;‚Äî</span></div>
    <div class="chip"><b>Resources</b><span id="uiResources">&nbsp;0</span></div>
  </div>

  <div class="tagline">Ship auto-collects rings ‚Ä¢ Wingmen defend ‚Ä¢ Use on-screen pad to nudge ‚Ä¢ Warp & Beam buttons on
    the right</div>

  <!-- On-screen controls -->
  <div id="pad" aria-label="Nudge Pad">
    <div id="stick"></div>
  </div>
  <div id="actions">
    <button class="act" id="sonicBtn">üí• Sonic Bomb (3)</button>
    <button class="act" id="warpBtn">‚ö° Warp</button>
    <button class="act" id="beamBtn">üß≤ Beam: Auto</button>
  </div>

  <!-- Cosmic Menu Overlay -->
  <div id="cosmicMenu" class="modal open" aria-modal="true" role="dialog">
    <div class="wrap">
      <h1>Choose Your Flight Style</h1>
      <div class="cards">
        <div class="card selected" data-mode="B">
          <div class="tag">B</div>
          <div class="title">Balanced</div>
          <div class="desc">Steady cadence ‚Ä¢ Smooth glide ‚Ä¢ Standard defense ‚Ä¢ Auto beam</div>
          <div class="stars"></div>
        </div>
        <div class="card" data-mode="A">
          <div class="tag">A</div>
          <div class="title">Arcade</div>
          <div class="desc">Fast rings ‚Ä¢ Strong catch-up ‚Ä¢ Aggressive wingmen ‚Ä¢ Auto beam</div>
          <div class="stars"></div>
        </div>
        <div class="card" data-mode="C">
          <div class="tag">C</div>
          <div class="title">Chill</div>
          <div class="desc">Relaxed pace ‚Ä¢ Bigger rings ‚Ä¢ Manual beam ‚Ä¢ Gentle waves</div>
          <div class="stars"></div>
        </div>
      </div>
      <div class="row">
        <button class="btn primary" id="startBtn">Start Flight</button>
        <button class="btn" id="toggleBeamAuto">Beam: Auto</button>
      </div>
    </div>
  </div>

  <!-- Level Summary Overlay -->
  <div id="levelSummary" class="modal" aria-modal="true" role="dialog">
    <div class="wrap">
      <h1 id="summaryTitle">Level 1 Complete!</h1>
      <div id="summaryChart">
        <div class="bar-item">
          <div class="bar" id="summaryBarKills"></div>
          <div class="bar-label">Kills</div>
          <div class="bar-value" id="summaryValueKills">0</div>
        </div>
        <div class="bar-item">
          <div class="bar" id="summaryBarResources"></div>
          <div class="bar-label">Resources</div>
          <div class="bar-value" id="summaryValueResources">0</div>
        </div>
        <div class="bar-item">
          <div class="bar" id="summaryBarScore"></div>
          <div class="bar-label">Score Bonus</div>
          <div class="bar-value" id="summaryValueScore">0</div>
        </div>
      </div>
      <p id="summaryNextLevel">Preparing for Level 2...</p>
    </div>
  </div>

  <canvas id="c"></canvas>

  <script>
    (function () {
      'use strict';
      function crashOverlay(msg) { try { var el = document.createElement('div'); el.style.cssText = 'position:fixed;top:10px;right:10px;z-index:99999;background:#9f1239;color:#fff;padding:6px 10px;border-radius:8px;font:12px/1.2 Inter, sans-serif;max-width:70vw;box-shadow:0 6px 20px rgba(0,0,0,.4)'; el.textContent = 'JS error: ' + msg; document.body.appendChild(el); } catch (_) { } }
      window.addEventListener('error', function (e) { crashOverlay(e.message); });

      // ====== Base Config + Modes ======
      var BASE = {
        DPR: Math.min(window.devicePixelRatio || 1, 1.5), // FPS Boost: Cap DPR
        SPEED: 210,
        STAR_FARTHEST: 80, STAR_FAR: 100, STAR_DEEP: 140, STAR_MID: 180, STAR_NEAR: 220, BOKEH: 30,
        ENEMY_WAVE_CHANCE: 0.08, ENEMY_WAVE_SIZE: [2, 3], ENEMY_HP: 3,
        BOLT_SPEED: 640, FIRE_COOLDOWN: 90, MAX_FIRE_RANGE: 560,
        RINGS_MIN: 15, RINGS_MAX: 30, RING_INTERVAL: [1.6, 3.0], RING_RADIUS: [30, 44],
        RES_SPAWN_CHANCE: 0.045,
        SHIP_X: 0.5, SHIP_Y: 0.78, SHIP_ACC_X: 3.2, SHIP_ACC_Y: 2.6, SHIP_DAMP: 0.88,
        SHIP_MAX_VX: 620, SHIP_MAX_VY: 520, CATCHUP_DIST: 220, CATCHUP_BOOST: 1.25,
        WING_OFFSET: 46, WING_COOLDOWN: 1000,
        BEAM_AUTO: true, BEAM_LEN: 220, BEAM_HALF_W: 92, BEAM_COOLDOWN: 900,
        SONIC_BOMB_COST: 3, SONIC_BOMB_COOLDOWN: 20000
      };
      var MODES = {
        A: { name: 'A ‚Ä¢ Arcade', RING_INTERVAL: [1.2, 2.4], SHIP_ACC_X: 3.8, SHIP_ACC_Y: 3.2, SHIP_MAX_VX: 700, SHIP_MAX_VY: 560, CATCHUP_BOOST: 1.35, ENEMY_WAVE_CHANCE: 0.12, ENEMY_WAVE_SIZE: [2, 4], RES_SPAWN_CHANCE: 0.06, BEAM_AUTO: true },
        B: { name: 'B ‚Ä¢ Balanced' },
        C: { name: 'C ‚Ä¢ Chill', RING_INTERVAL: [2.2, 3.8], SHIP_ACC_X: 2.6, SHIP_ACC_Y: 2.2, SHIP_MAX_VX: 520, SHIP_MAX_VY: 460, ENEMY_WAVE_CHANCE: 0.06, ENEMY_WAVE_SIZE: [1, 2], RES_SPAWN_CHANCE: 0.03, BEAM_AUTO: false }
      };
      var CFG = _merge(BASE, MODES.B);

      // ====== Canvas ======
      var canvas = document.getElementById('c');
      var ctx = canvas.getContext('2d', { alpha: false });
      if (!ctx) { crashOverlay('2D Canvas unavailable'); return; }
      var W = 1, H = 1;
      function resize() { W = canvas.width = Math.max(1, Math.floor(window.innerWidth * CFG.DPR)); H = canvas.height = Math.max(1, Math.floor(window.innerHeight * CFG.DPR)); canvas.style.width = window.innerWidth + 'px'; canvas.style.height = window.innerHeight + 'px'; }
      window.addEventListener('resize', resize, { passive: true }); resize(); ctx.imageSmoothingEnabled = true;

      // ====== DOM refs ======
      var uiMode = document.getElementById('uiMode'), uiLevel = document.getElementById('uiLevel'), uiScore = document.getElementById('uiScore'), uiRings = document.getElementById('uiRings'), uiEnemies = document.getElementById('uiEnemies'), uiKills = document.getElementById('uiKills'), uiBeam = document.getElementById('uiBeam'), uiFPS = document.getElementById('uiFPS'), uiResources = document.getElementById('uiResources');
      var menu = document.getElementById('cosmicMenu'), menuBtn = document.getElementById('menuBtn'), startBtn = document.getElementById('startBtn'), toggleBeamAuto = document.getElementById('toggleBeamAuto');
      var pad = document.getElementById('pad'), stick = document.getElementById('stick'), warpBtn = document.getElementById('warpBtn'), beamBtn = document.getElementById('beamBtn'), sonicBtn = document.getElementById('sonicBtn');
      var summary = document.getElementById('levelSummary'), summaryTitle = document.getElementById('summaryTitle'), summaryNextLevel = document.getElementById('summaryNextLevel');
      var summaryBarKills = document.getElementById('summaryBarKills'), summaryBarResources = document.getElementById('summaryBarResources'), summaryBarScore = document.getElementById('summaryBarScore');
      var summaryValueKills = document.getElementById('summaryValueKills'), summaryValueResources = document.getElementById('summaryValueResources'), summaryValueScore = document.getElementById('summaryValueScore');

      // ====== Helpers ======
      function R() { return Math.random(); }
      function rand(a, b) { return a + R() * (b - a); }
      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
      function lerp(a, b, t) { return a + (b - a) * t; }
      function nowMs() { return performance.now(); }
      function _merge(a, b) { var o = {}, k; for (k in a) { if (Object.prototype.hasOwnProperty.call(a, k)) o[k] = a[k]; } for (k in b) { if (Object.prototype.hasOwnProperty.call(b, k) && b[k] !== undefined) o[k] = b[k]; } return o; }

      // ====== Offscreen textures (FPS Boost) ======
      var TEX_BOLT, PRE_RINGS = {};
      function pregenTextures() {
        // Bolt
        var w = 64, h = 192, cn = document.createElement('canvas'); cn.width = w; cn.height = h; var g = cn.getContext('2d'); var grad = g.createLinearGradient(w / 2, 0, w / 2, h); grad.addColorStop(0, 'rgba(255,255,255,0)'); grad.addColorStop(0.15, 'rgba(182,235,255,0.75)'); grad.addColorStop(0.5, 'rgba(125,211,252,1)'); grad.addColorStop(0.85, 'rgba(192,132,252,0.75)'); grad.addColorStop(1, 'rgba(255,255,255,0)'); g.fillStyle = grad; g.fillRect(w * 0.42, 0, w * 0.16, h); g.globalCompositeOperation = 'lighter'; var glow = g.createLinearGradient(w / 2, 0, w / 2, h); glow.addColorStop(0, 'rgba(125,211,252,0)'); glow.addColorStop(0.5, 'rgba(125,211,252,0.35)'); glow.addColorStop(1, 'rgba(192,132,252,0)'); g.fillStyle = glow; g.fillRect(0, 0, w, h); TEX_BOLT = cn;
        // Rings
        [30, 34, 38, 42, 46].forEach(function (r) {
          var thick = Math.max(5, r * 0.22); var d = Math.ceil((r + thick) * 2); var cn = document.createElement('canvas'); cn.width = cn.height = d; var g = cn.getContext('2d'); g.translate(d / 2, d / 2); g.lineWidth = thick; g.strokeStyle = 'rgba(150,242,255,0.95)'; g.shadowColor = 'rgba(54,209,255,1)'; g.shadowBlur = thick * 1.5; g.beginPath(); g.arc(0, 0, r, 0, Math.PI * 2); g.stroke(); PRE_RINGS[r] = cn;
        });
      }

      // ====== Drawers ======
      function drawShip(x, y, rot, scale, color) { ctx.save(); ctx.translate(x, y); ctx.rotate(rot); ctx.scale(scale, scale); ctx.globalCompositeOperation = 'lighter'; var eg = ctx.createRadialGradient(0, 28, 2, 0, 28, 22); eg.addColorStop(0, 'rgba(102,204,255,0.8)'); eg.addColorStop(1, 'rgba(102,204,255,0)'); ctx.fillStyle = eg; ctx.beginPath(); ctx.ellipse(0, 28, 10, 18, 0, 0, 6.283); ctx.fill(); ctx.globalCompositeOperation = 'source-over'; ctx.fillStyle = color.body; ctx.strokeStyle = '#0f172a'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, -18); ctx.lineTo(12, 6); ctx.quadraticCurveTo(0, 12, -12, 6); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = color.accent; ctx.beginPath(); ctx.moveTo(0, -12); ctx.quadraticCurveTo(6, -4, 0, 0); ctx.quadraticCurveTo(-6, -4, 0, -12); ctx.fill(); ctx.fillStyle = '#9aa7bb'; ctx.beginPath(); ctx.moveTo(-18, 0); ctx.lineTo(-6, 6); ctx.lineTo(-2, 16); ctx.lineTo(-22, 10); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(18, 0); ctx.lineTo(6, 6); ctx.lineTo(2, 16); ctx.lineTo(22, 10); ctx.closePath(); ctx.fill(); ctx.fillStyle = color.detail; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(3, 12); ctx.lineTo(-3, 12); ctx.closePath(); ctx.fill(); ctx.restore(); }
      function drawSaucer(x, y, t) { ctx.save(); ctx.translate(x, y); ctx.rotate(Math.sin((t + y) * 0.4) * 0.02); ctx.globalCompositeOperation = 'lighter'; var g = ctx.createRadialGradient(0, 6, 2, 0, 6, 22); g.addColorStop(0, 'rgba(255,180,220,0.6)'); g.addColorStop(1, 'rgba(255,180,220,0)'); ctx.fillStyle = g; ctx.beginPath(); ctx.ellipse(0, 12, 18, 8, 0, 0, 6.283); ctx.fill(); ctx.globalCompositeOperation = 'source-over'; ctx.fillStyle = '#ffe0ea'; ctx.strokeStyle = 'rgba(120,30,60,0.8)'; ctx.lineWidth = 1.8; ctx.beginPath(); ctx.ellipse(0, -2, 10, 8, 0, 0, Math.PI); ctx.fill(); ctx.stroke(); var diskGrad = ctx.createLinearGradient(-20, 0, 20, 0); diskGrad.addColorStop(0, '#7f2647'); diskGrad.addColorStop(1, '#a63e63'); ctx.fillStyle = diskGrad; ctx.beginPath(); ctx.ellipse(0, 6, 22, 10, 0, 0, 6.283); ctx.fill(); ctx.stroke(); ctx.globalCompositeOperation = 'lighter'; var i; for (i = -2; i <= 2; i++) { var lx = -12 + i * 6; var ly = 8 + Math.sin(t * 2 + i) * 1.2; var lg = ctx.createRadialGradient(lx, ly, 0, lx, ly, 4); lg.addColorStop(0, 'rgba(255,100,150,0.9)'); lg.addColorStop(1, 'rgba(255,100,150,0)'); ctx.fillStyle = lg; ctx.beginPath(); ctx.arc(lx, ly, 4, 0, 6.283); ctx.fill(); } ctx.restore(); }
      function drawBlinkWingman(x, y, t) { ctx.save(); ctx.translate(x, y); ctx.globalCompositeOperation = 'lighter'; var halo = ctx.createRadialGradient(0, 0, 0, 0, 0, 16); halo.addColorStop(0, 'rgba(160,200,255,0.8)'); halo.addColorStop(1, 'rgba(160,200,255,0)'); ctx.fillStyle = halo; ctx.beginPath(); ctx.arc(0, 0, 16, 0, 6.283); ctx.fill(); ctx.globalCompositeOperation = 'source-over'; ctx.fillStyle = '#c7d2fe'; ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1.6; ctx.beginPath(); ctx.moveTo(0, -7); ctx.lineTo(9, 1); ctx.lineTo(0, 9); ctx.lineTo(-9, 1); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#8aa2ff'; ctx.beginPath(); ctx.arc(0, 1.5, 3.5, 0, 6.283); ctx.fill(); ctx.restore(); }
      function drawResource(x, y, rot) { ctx.save(); ctx.translate(x, y); ctx.rotate(rot); ctx.globalCompositeOperation = 'lighter'; var grad = ctx.createLinearGradient(-8, -8, 8, 8); grad.addColorStop(0, '#5eead4'); grad.addColorStop(1, '#a7f3d0'); ctx.fillStyle = grad; ctx.strokeStyle = 'rgba(16,94,84,0.5)'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(8, 0); ctx.lineTo(0, 10); ctx.lineTo(-8, 0); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore(); }
      function drawBike(x, y, t) { ctx.save(); ctx.translate(x, y); ctx.rotate(Math.sin(t * 2.4) * 0.06); ctx.fillStyle = '#e2e8f0'; ctx.strokeStyle = '#0f172a'; ctx.lineWidth = 1.6; ctx.beginPath(); ctx.ellipse(0, 0, 10, 6, 0, 0, 6.283); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#93c5fd'; ctx.beginPath(); ctx.moveTo(0, -6); ctx.lineTo(4, 0); ctx.lineTo(0, 6); ctx.closePath(); ctx.fill(); ctx.restore(); }
      function drawTargetIndicator(x, y, t) { ctx.save(); ctx.translate(x, y); ctx.strokeStyle = 'rgba(110, 231, 183, 0.8)'; ctx.lineWidth = 2; ctx.shadowColor = 'rgba(52, 211, 153, 1)'; ctx.shadowBlur = 8; var angle = (t / 300) % (Math.PI * 2); var size = 10 + Math.sin(t / 150) * 2; for (var i = 0; i < 4; i++) { var a = angle + i * Math.PI / 2; ctx.beginPath(); ctx.moveTo(Math.cos(a) * size, Math.sin(a) * size); ctx.lineTo(Math.cos(a) * (size + 6), Math.sin(a) * (size + 6)); ctx.stroke(); } ctx.restore(); }

      // ====== State ======
      var gameState = 'menu'; // 'menu', 'playing', 'summary'
      var level = 1, score = 0, totalKills = 0, totalResources = 0;
      var levelKills = 0, levelResources = 0;
      var ringsCleared = 0, ringsGoal = 0, nextRingAt = 0;
      var bullets = [], enemies = [], rings = [], farthest = [], far = [], deep = [], mid = [], near = [], bokeh = [], effects = [], resources = [];
      var objective = null;
      var wingmen = [{ state: 'dock', cool: 0, x: 0, y: 0, target: -1, fireCd: 0, tpT: 0, side: -1 }, { state: 'dock', cool: 0, x: 0, y: 0, target: -1, fireCd: 0, tpT: 0, side: 1 }];
      var harvester = { state: 'dock', x: 0, y: 0, target: -1, grab: false, cd: 0 };
      var ship = { x: W * BASE.SHIP_X, y: H * BASE.SHIP_Y, vx: 0, vy: 0, rot: 0, warp: 0 };
      var shipColors = [{ body: '#c6d0e6', accent: '#90a8ff', detail: '#6f6cf8' }, { body: '#d1fae5', accent: '#6ee7b7', detail: '#10b981' }, { body: '#fef3c7', accent: '#fcd34d', detail: '#f59e0b' }, { body: '#fee2e2', accent: '#fca5a5', detail: '#ef4444' }];
      var currentShipColor = shipColors[0];
      var input = { x: 0, y: 0 };
      var beam = { auto: BASE.BEAM_AUTO, active: false, cd: 0 };
      var sonicBomb = { cd: 0 };
      var summaryTimeout;

      // ====== Level / HUD ======
      function resetForLevel() { ringsCleared = 0; ringsGoal = Math.floor(rand(BASE.RINGS_MIN, BASE.RINGS_MAX + 1)); nextRingAt = nowMs() + rand(CFG.RING_INTERVAL[0], CFG.RING_INTERVAL[1]) * 1000; rings.length = 0; enemies.length = 0; bullets.length = 0; effects.length = 0; resources.length = 0; levelKills = 0; levelResources = 0; objective = null; uiLevel.textContent = String(level); updateHUD(); }
      function updateHUD() { uiScore.textContent = String(score); uiRings.textContent = String(ringsCleared) + '/' + String(ringsGoal); uiEnemies.textContent = String(enemies.length); uiKills.textContent = String(totalKills + levelKills); uiBeam.textContent = (beam.auto ? 'Auto' : (beam.active ? 'On' : 'Off')); uiMode.textContent = (CFG.name || 'B ‚Ä¢ Balanced'); uiResources.textContent = String(totalResources + levelResources); }

      // ====== Sky systems ======
      function makeStars(arr, count) { var i; arr.length = 0; for (i = 0; i < count; i++) { arr.push({ x: R() * W, y: R() * H, o: rand(0.2, 1) }); } }
      function makeBokeh(arr, count) { var i; arr.length = 0; for (i = 0; i < count; i++) { arr.push({ x: R() * W, y: R() * H, r: rand(1.2, 3.2), blur: rand(3, 10), a: rand(0.28, 0.55) }); } }
      function regenSky() { makeStars(farthest, CFG.STAR_FARTHEST); makeStars(far, CFG.STAR_FAR); makeStars(deep, CFG.STAR_DEEP); makeStars(mid, CFG.STAR_MID); makeStars(near, CFG.STAR_NEAR); makeBokeh(bokeh, CFG.BOKEH); }

      // ====== Menu & Game Flow ======
      function randomizeStars(el) { var s = el.querySelector('.stars'); if (!s) return; s.innerHTML = ''; var i; for (i = 0; i < 24; i++) { var sp = document.createElement('span'); sp.style.left = (Math.random() * 100) + '%'; sp.style.top = (Math.random() * 100) + '%'; s.appendChild(sp); } }
      var cards = document.querySelectorAll('.card'); var ci; for (ci = 0; ci < cards.length; ci++) { randomizeStars(cards[ci]); }
      function applyModeKey(key) { var sel = (key === 'A') ? MODES.A : (key === 'C') ? MODES.C : MODES.B; CFG = _merge(BASE, sel); CFG.name = sel.name || 'B ‚Ä¢ Balanced'; beam.auto = (sel.BEAM_AUTO !== undefined) ? sel.BEAM_AUTO : BASE.BEAM_AUTO; beamBtn.textContent = 'üß≤ Beam: ' + (beam.auto ? 'Auto' : 'Manual'); updateHUD(); regenSky(); }
      var currentModeKey = 'B';
      function startGame() { currentModeKey = currentModeKey || 'B'; applyModeKey(currentModeKey); level = 1; score = 0; totalKills = 0; totalResources = 0; menu.classList.remove('open'); startNextLevel(); }
      function startNextLevel() { clearTimeout(summaryTimeout); summary.classList.remove('open'); currentShipColor = shipColors[level % shipColors.length]; resetForLevel(); regenSky(); gameState = 'playing'; }
      function showLevelSummary() {
        totalKills += levelKills; totalResources += levelResources; var scoreBonus = levelKills * 15 + levelResources * 25; score += scoreBonus; gameState = 'summary'; summaryTitle.textContent = 'Level ' + level + ' Complete!'; summaryValueKills.textContent = levelKills; summaryValueResources.textContent = levelResources; summaryValueScore.textContent = scoreBonus; summaryNextLevel.textContent = 'Preparing for Level ' + (level + 1) + '...';
        var maxStat = Math.max(1, levelKills, levelResources, scoreBonus);
        setTimeout(function () {
          summaryBarKills.style.height = (levelKills / maxStat * 100) + '%';
          summaryBarResources.style.height = (levelResources / maxStat * 100) + '%';
          summaryBarScore.style.height = (scoreBonus / maxStat * 100) + '%';
        }, 100);
        summary.classList.add('open'); level++; summaryTimeout = setTimeout(startNextLevel, 4000);
      }
      menuBtn.addEventListener('click', function () { menu.classList.add('open'); gameState = 'menu'; });
      startBtn.addEventListener('click', startGame);
      toggleBeamAuto.addEventListener('click', function () { beam.auto = !beam.auto; toggleBeamAuto.textContent = 'Beam: ' + (beam.auto ? 'Auto' : 'Manual'); beamBtn.textContent = 'üß≤ Beam: ' + (beam.auto ? 'Auto' : 'Manual'); updateHUD(); });
      for (ci = 0; ci < cards.length; ci++) { (function (card) { card.addEventListener('click', function () { for (var i = 0; i < cards.length; i++) { cards[i].classList.remove('selected'); } card.classList.add('selected'); var m = card.getAttribute('data-mode') || 'B'; currentModeKey = m; applyModeKey(m); }); })(cards[ci]); }

      // ====== On‚Äëscreen Nudge Pad ======
      var dragging = false; var PAD_R = 56; function setStick(dx, dy) { stick.style.transform = 'translate(' + dx + 'px,' + dy + 'px)'; }
      function updateInputFromPoint(px, py) { var rect = pad.getBoundingClientRect(); var cx = rect.left + rect.width / 2, cy = rect.top + rect.height / 2; var dx = px - cx, dy = py - cy; var dist = Math.min(Math.hypot(dx, dy), PAD_R); var ang = Math.atan2(dy, dx); var nx = Math.cos(ang) * dist / PAD_R, ny = Math.sin(ang) * dist / PAD_R; input.x = nx; input.y = ny; }
      function endDrag() { dragging = false; input.x = 0; input.y = 0; }
      pad.addEventListener('pointerdown', function (e) { dragging = true; pad.setPointerCapture(e.pointerId); updateInputFromPoint(e.clientX, e.clientY); });
      pad.addEventListener('pointermove', function (e) { if (!dragging) return; updateInputFromPoint(e.clientX, e.clientY); });
      pad.addEventListener('pointerup', endDrag); pad.addEventListener('pointercancel', endDrag); pad.addEventListener('lostpointercapture', endDrag);
      warpBtn.addEventListener('click', function () { if (gameState === 'playing') ship.warp = 1; });
      beamBtn.addEventListener('click', function () { if (beam.auto) { beam.auto = false; } else { beam.active = !beam.active; } beamBtn.textContent = 'üß≤ Beam: ' + (beam.auto ? 'Auto' : (beam.active ? 'On' : 'Manual')); updateHUD(); });
      sonicBtn.addEventListener('click', function () { if (gameState === 'playing' && sonicBomb.cd <= 0 && (totalResources + levelResources) >= CFG.SONIC_BOMB_COST) { totalResources -= CFG.SONIC_BOMB_COST; if (totalResources < 0) { levelResources += totalResources; totalResources = 0; } sonicBomb.cd = CFG.SONIC_BOMB_COOLDOWN; enemies.forEach(function (e) { effects.push({ x: e.x, y: e.y, t: 260, r: 36 }); }); enemies.length = 0; effects.push({ x: ship.x, y: ship.y, t: 800, r: W, sonic: true }); } });

      // ====== Spawners ======
      function spawnRing() { var r = rand(CFG.RING_RADIUS[0], CFG.RING_RADIUS[1]); var key = Object.keys(PRE_RINGS).reduce(function (prev, curr) { return (Math.abs(curr - r) < Math.abs(prev - r) ? curr : prev); }); rings.push({ x: clamp(ship.x + rand(-W * 0.35, W * 0.35), W * 0.08, W * 0.92), y: -r - 20, r: parseInt(key), tex: PRE_RINGS[key] }); }
      function spawnEnemyWave() { var n = Math.floor(rand(CFG.ENEMY_WAVE_SIZE[0], CFG.ENEMY_WAVE_SIZE[1] + 1)); var i; for (i = 0; i < n; i++) { var side = (R() < 0.5) ? -1 : 1; var ex = (side < 0) ? rand(W * 0.05, W * 0.4) : rand(W * 0.6, W * 0.95); enemies.push({ x: ex, y: -40 - i * 30, vx: rand(-40, 40), vy: rand(100, 150), hp: CFG.ENEMY_HP, phase: rand(0, 6.28), ttl: 12000, drift: rand(0.6, 1.2) }); } }
      function spawnResource() { resources.push({ x: rand(W * 0.25, W * 0.75), y: -20, vx: rand(-20, 20), vy: rand(40, 80), rot: R() * 6.28 }); }

      // ====== Bullets ======
      function fireBolt(x, y, tx, ty) { var dx = tx - x, dy = ty - y; var len = Math.hypot(dx, dy) || 1; var vx = dx / len * CFG.BOLT_SPEED, vy = dy / len * CFG.BOLT_SPEED; bullets.push({ x: x, y: y, vx: vx, vy: vy, life: 900, kind: 'bolt' }); }
      function fireOrb(x, y, ang, speed) { bullets.push({ x: x, y: y, vx: Math.cos(ang) * speed, vy: Math.sin(ang) * speed, life: 700, kind: 'orb' }); }
      function fireRadial(x, y, count, speed) { var i; for (i = 0; i < count; i++) { var ang = (i / count) * Math.PI * 2; fireOrb(x, y, ang, speed); } }
      function drawBullet(b) { if (b.kind === 'bolt') { var a = Math.atan2(b.vy, b.vx) - Math.PI / 2; ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(a); ctx.drawImage(TEX_BOLT, -TEX_BOLT.width / 2, -TEX_BOLT.height * 0.55, TEX_BOLT.width, TEX_BOLT.height * 0.9); ctx.restore(); } else { ctx.save(); ctx.globalCompositeOperation = 'lighter'; var rg = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, 6); rg.addColorStop(0, 'rgba(125,211,252,1)'); rg.addColorStop(1, 'rgba(125,211,252,0)'); ctx.fillStyle = rg; ctx.beginPath(); ctx.arc(b.x, b.y, 6, 0, 6.283); ctx.fill(); ctx.restore(); } }

      // ====== Objective selection ======
      function validRing(r) { return r && (rings.indexOf(r) !== -1); }
      function chooseObjective() {
        if (objective && validRing(objective.ref) && objective.ref.y > ship.y - objective.ref.r) { return; }
        var bestR = null, bestDy = 1e9, i;
        for (i = 0; i < rings.length; i++) {
          var r = rings[i];
          // UPDATED: Target rings between 40% and 80% of screen height
          if (r.y < H * 0.8 && r.y > H * 0.4) {
            var dy = Math.abs(r.y - (ship.y - 80));
            if (dy < bestDy) { bestDy = dy; bestR = r; }
          }
        }
        objective = bestR ? { type: 'ring', ref: bestR } : null;
      }

      // ====== Wingmen AI ======
      function updateWingman(w, dt, t) { w.cool = Math.max(0, w.cool - dt); w.fireCd = Math.max(0, w.fireCd - dt); w.tpT = Math.max(0, w.tpT - dt); var dockX = ship.x + w.side * CFG.WING_OFFSET, dockY = ship.y + 8; if (w.state === 'dock') { w.x = dockX; w.y = dockY; if (enemies.length >= 1 && w.cool <= 0) { w.state = 'launch'; } } else if (w.state === 'launch') { w.x = lerp(w.x || dockX, dockX, 0.1); w.y = lerp(w.y || dockY, ship.y - 60, 0.1); if (Math.abs((w.y || dockY) - (ship.y - 60)) < 5) { w.state = 'attack'; w.target = -1; w.tpT = 0; } } else if (w.state === 'attack') { if (enemies.length === 0) { w.state = 'return'; } else { if (w.target < 0 || !enemies[w.target]) { var best = 1e9, idx = -1, j; for (j = 0; j < enemies.length; j++) { var e = enemies[j]; if (w.side < 0 ? e.x > W / 2 : e.x < W / 2) continue; var ahead = (e.y < ship.y - 10); if (!ahead) continue; var d = Math.hypot(e.x - (w.x || dockX), e.y - (w.y || dockY)); if (d < best) { best = d; idx = j; } } w.target = idx; } var tar = enemies[w.target]; if (!tar) { w.state = 'return'; } else { if (w.tpT <= 0) { var ang = (t * 0.002 + (w.side > 0 ? 0 : Math.PI)) % (Math.PI * 2); var radius = 48; w.x = tar.x + Math.cos(ang) * radius; w.y = tar.y + Math.sin(ang) * radius; w.tpT = 220; if (w.fireCd <= 0) { if (R() < 0.5) { fireRadial(w.x, w.y, 6, 220); } else { var a = Math.atan2(tar.y - w.y, tar.x - w.x); fireOrb(w.x, w.y, a, 280); fireOrb(w.x, w.y, a + 0.12, 260); fireOrb(w.x, w.y, a - 0.12, 260); } w.fireCd = 220; } } else { w.x = lerp(w.x, tar.x + w.side * 36, 0.08); w.y = lerp(w.y, tar.y, 0.08); } if (tar.y > ship.y + 120) { w.state = 'return'; } } } } else if (w.state === 'return') { w.x = lerp(w.x, dockX, 0.12); w.y = lerp(w.y, dockY, 0.12); if (Math.hypot(w.x - dockX, w.y - dockY) < 4) { w.state = 'cool'; w.cool = CFG.WING_COOLDOWN; } } else if (w.state === 'cool') { w.x = dockX; w.y = dockY; if (w.cool <= 0) { w.state = 'dock'; } } }

      // ====== Harvester AI ======
      function updateHarvester(h, dt) { h.cd = Math.max(0, h.cd - dt); var dockX = ship.x, dockY = ship.y - 16; if (h.state === 'dock') { h.x = dockX; h.y = dockY; h.grab = false; if (resources.length > 0 && h.cd <= 0) { var idx = -1, bestDy = 0, i; for (i = 0; i < resources.length; i++) { var s = resources[i]; var ahead = (s.y < ship.y - 10); if (!ahead) continue; var dy = ship.y - s.y; if (dy > bestDy) { bestDy = dy; idx = i; } } if (idx >= 0) { h.target = idx; h.state = 'seek'; } } } else if (h.state === 'seek') { var s = resources[h.target]; if (!s) { h.state = 'return'; } else { h.x = lerp(h.x, s.x, 0.16); h.y = lerp(h.y, s.y + 20, 0.16); if (Math.hypot(h.x - s.x, h.y - s.y) < 16) { h.state = 'grab'; h.grab = true; } if (s.y > ship.y + 60) { h.state = 'return'; } } } else if (h.state === 'grab') { var s2 = resources[h.target]; if (!s2) { h.state = 'return'; } else { h.x = lerp(h.x, dockX, 0.14); h.y = lerp(h.y, dockY, 0.14); s2.x = lerp(s2.x, dockX, 0.18); s2.y = lerp(s2.y, dockY, 0.18); if (Math.hypot(s2.x - dockX, s2.y - dockY) < 12) { var idxS = resources.indexOf(s2); if (idxS !== -1) resources.splice(idxS, 1); score += 25; levelResources++; updateHUD(); h.state = 'return'; h.cd = 1200; } } } else if (h.state === 'return') { h.x = lerp(h.x, dockX, 0.14); h.y = lerp(h.y, dockY, 0.14); if (Math.hypot(h.x - dockX, h.y - dockY) < 4) { h.state = 'dock'; h.grab = false; } } }

      // ====== Main Game Loop ======
      var lastT = nowMs(), accFps = 0, frames = 0;
      function tick() {
        var t = nowMs(); var dt = Math.min(33, t - lastT); lastT = t;
        requestAnimationFrame(tick);

        if (gameState !== 'playing') {
          if (gameState === 'menu') { /* menu logic can go here if needed */ }
          return;
        }

        var dtSec = dt / 1000;
        var tts = t / 1000; // BUGFIX: Define tts for animations
        sonicBomb.cd = Math.max(0, sonicBomb.cd - dt);

        if (t >= nextRingAt) { spawnRing(); nextRingAt = t + rand(CFG.RING_INTERVAL[0], CFG.RING_INTERVAL[1]) * 1000; }
        if (R() < CFG.ENEMY_WAVE_CHANCE * dtSec) { spawnEnemyWave(); }
        if (R() < CFG.RES_SPAWN_CHANCE * dtSec) { spawnResource(); }

        chooseObjective();
        var desiredX = objective ? objective.ref.x : ship.x;
        // UPDATED: AI respects new ship Y constraints
        var desiredY = objective ? clamp(objective.ref.y + 40, H * 0.7, H * 0.8) : H * 0.75;
        var far = objective ? (Math.hypot(desiredX - ship.x, desiredY - ship.y) > CFG.CATCHUP_DIST) : false; var boost = far ? CFG.CATCHUP_BOOST : 1;
        var aiVX = (desiredX - ship.x) * CFG.SHIP_ACC_X * boost; var aiVY = (desiredY - ship.y) * CFG.SHIP_ACC_Y * boost;
        var stickDX = clamp(aiVX / CFG.SHIP_MAX_VX, -1, 1) + input.x; var stickDY = clamp(aiVY / CFG.SHIP_MAX_VY, -1, 1) + input.y;
        setStick(clamp(stickDX, -1, 1) * PAD_R, clamp(stickDY, -1, 1) * PAD_R);
        var nudgeX = input.x * 220, nudgeY = input.y * 180; ship.vx += (aiVX + nudgeX) * dtSec; ship.vy += (aiVY + nudgeY) * dtSec; ship.vx = clamp(ship.vx, -CFG.SHIP_MAX_VX * boost, CFG.SHIP_MAX_VX * boost); ship.vy = clamp(ship.vy, -CFG.SHIP_MAX_VY * boost, CFG.SHIP_MAX_VY * boost); ship.vx *= CFG.SHIP_DAMP; ship.vy *= CFG.SHIP_DAMP; ship.x += ship.vx * dtSec; ship.y += ship.vy * dtSec;
        // UPDATED: Ship Y position is constrained
        ship.x = clamp(ship.x, W * 0.08, W * 0.92); ship.y = clamp(ship.y, H * 0.7, H * 0.8);
        ship.rot = lerp(ship.rot, clamp(ship.vx, -260, 260) / 1000, 0.2);
        var scroll = (BASE.SPEED + (ship.warp ? 220 : 0)) * dtSec; ship.warp = 0;

        // Parallax
        var i;
        [farthest, far, deep, mid, near].forEach(function (layer, index) {
          var speed = [0.05, 0.1, 0.22, 0.5, 0.95][index];
          for (i = 0; i < layer.length; i++) { var s = layer[i]; s.y += scroll * speed; if (s.y > H) { s.y = 0; s.x = R() * W; } }
        });
        for (i = 0; i < bokeh.length; i++) { var bk = bokeh[i]; bk.y += scroll * 0.25; if (bk.y > H) { bk.y = 0; bk.x = R() * W; } }

        // Rings
        for (i = rings.length - 1; i >= 0; i--) { var r = rings[i]; r.y += scroll * 0.8; var d = Math.hypot(r.x - ship.x, r.y - ship.y); if (d < r.r * 1.15) { rings.splice(i, 1); ringsCleared++; score += 10; if (R() < 0.6) spawnResource(); if (objective && objective.ref === r) { objective = null; } if (ringsCleared >= ringsGoal) { showLevelSummary(); } else { updateHUD(); } } else if (r.y - r.r > H + 60) { rings.splice(i, 1); if (objective && objective.ref === r) { objective = null; } } }

        // Enemies
        for (i = enemies.length - 1; i >= 0; i--) { var e = enemies[i]; e.ttl -= dt; var swayX = Math.sin((t * 0.002 + e.phase) * 2.0) * 40 * e.drift; var swayY = Math.cos((t * 0.002 + e.phase) * 1.6) * 10 * e.drift; e.x += (e.vx * dtSec) + swayX * dtSec; e.y += (e.vy * dtSec) + (scroll * 0.25) + swayY * dtSec; if (e.x < 20 || e.x > W - 20) e.vx *= -1; if (e.y > H + 60 || e.ttl <= 0) { enemies.splice(i, 1); } }
        for (i = 0; i < wingmen.length; i++) { updateWingman(wingmen[i], dt, t); }
        updateHarvester(harvester, dt);

        // Bullets
        for (i = bullets.length - 1; i >= 0; i--) { var b = bullets[i]; b.x += b.vx * dtSec; b.y += b.vy * dtSec - scroll * 0.05; b.life -= dt; if (b.life <= 0 || b.x < -80 || b.x > W + 80 || b.y < -120 || b.y > H + 120) { bullets.splice(i, 1); continue; } for (var j = enemies.length - 1; j >= 0; j--) { var en = enemies[j]; var hitR = (b.kind === 'orb' ? 10 : 22); var d2 = (en.x - b.x) * (en.x - b.x) + (en.y - b.y) * (en.y - b.y); if (d2 < hitR * hitR) { en.hp--; bullets.splice(i, 1); score += 15; if (en.hp <= 0) { enemies.splice(j, 1); levelKills++; updateHUD(); effects.push({ x: en.x, y: en.y, t: 260, r: 36 }); } break; } } }

        // Beam & Resources
        beam.cd = Math.max(0, beam.cd - dt); if (beam.auto && resources.length > 0 && beam.cd <= 0) { beam.active = true; }
        for (i = resources.length - 1; i >= 0; i--) { var s = resources[i]; if (harvester.grab && i === harvester.target) { continue; } s.x += s.vx * dtSec; s.y += s.vy * dtSec + scroll * 0.4; s.rot += 0.02; if (beam.active) { var bx = ship.x, by = ship.y - 8; var dx3 = s.x - bx, dy3 = s.y - by; if (dy3 < 0 && -dy3 < CFG.BEAM_LEN) { var half = CFG.BEAM_HALF_W * (-dy3 / CFG.BEAM_LEN); if (Math.abs(dx3) < half) { s.x = lerp(s.x, bx, 0.18); s.y = lerp(s.y, by, 0.18); if (Math.hypot(s.x - bx, s.y - by) < 12) { resources.splice(i, 1); score += 25; levelResources++; updateHUD(); continue; } } } } if (s.y > H + 40) { resources.splice(i, 1); } }
        if (beam.active) { beam.cd = CFG.BEAM_COOLDOWN; }
        for (i = effects.length - 1; i >= 0; i--) { var fx = effects[i]; fx.t -= dt; if (fx.t <= 0) effects.splice(i, 1); }

        // ====== Render ======
        ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, W, H);
        var bg = ctx.createLinearGradient(0, 0, 0, H); bg.addColorStop(0, '#050a1a'); bg.addColorStop(1, '#020612'); ctx.fillStyle = bg; ctx.fillRect(0, 0, W, H);
        ctx.save(); ctx.globalCompositeOperation = 'screen'; ctx.fillStyle = currentShipColor.accent; ctx.globalAlpha = 0.05 + (level - 1) * 0.01; ctx.fillRect(0, 0, W, H); ctx.restore();

        // Stars
        ctx.fillStyle = 'rgba(150,170,230,0.2)'; for (i = 0; i < farthest.length; i++) { ctx.fillRect(farthest[i].x | 0, farthest[i].y | 0, 1, 1); }
        ctx.fillStyle = 'rgba(150,170,230,0.3)'; for (i = 0; i < far.length; i++) { ctx.fillRect(far[i].x | 0, far[i].y | 0, 1, 1); }
        ctx.fillStyle = 'rgba(150,170,230,0.5)'; for (i = 0; i < deep.length; i++) { ctx.fillRect(deep[i].x | 0, deep[i].y | 0, 1, 1); }
        for (var bki = 0; bki < bokeh.length; bki++) { var bb = bokeh[bki]; ctx.save(); ctx.shadowBlur = bb.blur; ctx.shadowColor = 'rgba(170,190,255,' + bb.a + ')'; ctx.beginPath(); ctx.arc(bb.x, bb.y, bb.r, 0, 6.283); ctx.fillStyle = 'rgba(170,190,255,0)'; ctx.fill(); ctx.restore(); }
        ctx.fillStyle = 'rgba(190,205,255,0.85)'; for (i = 0; i < mid.length; i++) { ctx.fillRect(mid[i].x | 0, mid[i].y | 0, 1, 1); }
        ctx.fillStyle = 'rgba(230,238,255,1)'; for (i = 0; i < near.length; i++) { ctx.fillRect(near[i].x | 0, near[i].y | 0, 1, 1); }

        // Rings & Resources
        for (i = 0; i < rings.length; i++) { var rr = rings[i]; ctx.drawImage(rr.tex, (rr.x - rr.tex.width / 2) | 0, (rr.y - rr.tex.height / 2) | 0); }
        if (objective && objective.type === 'ring' && validRing(objective.ref)) { drawTargetIndicator(objective.ref.x, objective.ref.y, t); }
        for (i = resources.length - 1; i >= 0; i--) { var res = resources[i]; drawResource(res.x, res.y, res.rot); }

        // Enemies & FX
        for (i = 0; i < enemies.length; i++) { drawSaucer(enemies[i].x, enemies[i].y, tts); }
        ctx.save(); ctx.globalCompositeOperation = 'lighter'; for (i = 0; i < bullets.length; i++) { drawBullet(bullets[i]); } ctx.restore();
        for (i = effects.length - 1; i >= 0; i--) { var fx = effects[i]; var k = fx.t / (fx.sonic ? 800 : 260); ctx.save(); ctx.globalCompositeOperation = 'lighter'; if (fx.sonic) { ctx.strokeStyle = 'rgba(167,243,208,' + (0.8 * k) + ')'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(fx.x, fx.y, fx.r * (1 - k), 0, 6.283); ctx.stroke(); } else { var rg = ctx.createRadialGradient(fx.x, fx.y, 0, fx.x, fx.y, fx.r); rg.addColorStop(0, 'rgba(255,255,255,' + (0.6 * k) + ')'); rg.addColorStop(1, 'rgba(255,255,255,0)'); ctx.fillStyle = rg; ctx.beginPath(); ctx.arc(fx.x, fx.y, fx.r * (1.2 - k * 0.2), 0, 6.283); ctx.fill(); } ctx.restore(); }

        // Ship Beam
        if (beam.active) { var bx = ship.x, by = ship.y - 8, len = CFG.BEAM_LEN, half = CFG.BEAM_HALF_W; ctx.save(); ctx.globalCompositeOperation = 'lighter'; var grad2 = ctx.createLinearGradient(bx, by, bx, by - len); grad2.addColorStop(0, 'rgba(125,211,252,0.45)'); grad2.addColorStop(1, 'rgba(192,132,252,0.0)'); ctx.fillStyle = grad2; ctx.beginPath(); ctx.moveTo(bx, by); ctx.lineTo(bx - half, by - len); ctx.lineTo(bx + half, by - len); ctx.closePath(); ctx.fill(); ctx.restore(); beam.active = false; }

        // Harvester
        if (harvester.state !== 'dock') { var hx = harvester.x, hy = harvester.y; var sx = ship.x, sy = ship.y - 10; ctx.save(); ctx.strokeStyle = 'rgba(186,230,253,0.5)'; ctx.lineWidth = 1.2; ctx.beginPath(); ctx.moveTo(sx, sy); var mx = lerp(sx, hx, 0.5), my = lerp(sy, hy, 0.5) + 12; ctx.quadraticCurveTo(mx, my, hx, hy); ctx.stroke(); ctx.restore(); }
        if (harvester.state === 'grab') { var hx2 = harvester.x, hy2 = harvester.y; ctx.save(); ctx.globalCompositeOperation = 'lighter'; var gr = ctx.createLinearGradient(hx2, hy2, hx2, hy2 - 38); gr.addColorStop(0, 'rgba(167,243,208,0.6)'); gr.addColorStop(1, 'rgba(167,243,208,0)'); ctx.fillStyle = gr; ctx.beginPath(); ctx.moveTo(hx2, hy2); ctx.lineTo(hx2 - 14, hy2 - 38); ctx.lineTo(hx2 + 14, hy2 - 38); ctx.closePath(); ctx.fill(); ctx.restore(); }

        // Actors
        drawBlinkWingman(wingmen[0].x || ship.x - 46, wingmen[0].y || ship.y + 8, tts);
        drawBlinkWingman(wingmen[1].x || ship.x + 46, wingmen[1].y || ship.y + 8, tts);
        drawBike(harvester.x || ship.x, harvester.y || ship.y - 16, tts);
        drawShip(ship.x, ship.y, ship.rot, 1, currentShipColor);

        // HUD Update
        var res = totalResources + levelResources; var cd = sonicBomb.cd / 1000;
        sonicBtn.disabled = res < CFG.SONIC_BOMB_COST || cd > 0;
        sonicBtn.textContent = cd > 0 ? 'üí• Recharging (' + cd.toFixed(1) + 's)' : 'üí• Sonic Bomb (' + CFG.SONIC_BOMB_COST + ')';
        updateHUD(); frames++; accFps += dt; if (accFps > 250) { uiFPS.textContent = String(Math.round(1000 / (accFps / frames))); accFps = 0; frames = 0; }
      }

      // First paint & show menu
      pregenTextures();
      (function firstPaint() { ctx.fillStyle = '#070a18'; ctx.fillRect(0, 0, W, H); regenSky(); requestAnimationFrame(tick); })();
    })();
  </script>
</body>

</html>